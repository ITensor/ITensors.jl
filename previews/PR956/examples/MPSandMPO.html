<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MPS and MPO Examples · ITensors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ITensors.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="../getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="../getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="../getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="../getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="../tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="../tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="ITensor.html">ITensor Examples</a></li><li class="is-active"><a class="tocitem" href="MPSandMPO.html">MPS and MPO Examples</a><ul class="internal"><li><a class="tocitem" href="#Creating-an-MPS-from-a-Tensor"><span>Creating an MPS from a Tensor</span></a></li><li><a class="tocitem" href="#Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS"><span>Obtaining Elements of a Tensor Represented by an MPS</span></a></li><li><a class="tocitem" href="#Expected-Value-of-Local-Operators"><span>Expected Value of Local Operators</span></a></li><li><a class="tocitem" href="#Computing-Correlation-Functions"><span>Computing Correlation Functions</span></a></li><li><a class="tocitem" href="#Applying-a-Single-site-Operator-to-an-MPS"><span>Applying a Single-site Operator to an MPS</span></a></li><li><a class="tocitem" href="#Applying-a-Two-site-Operator-to-an-MPS"><span>Applying a Two-site Operator to an MPS</span></a></li><li><a class="tocitem" href="#Computing-the-Entanglement-Entropy-of-an-MPS"><span>Computing the Entanglement Entropy of an MPS</span></a></li><li><a class="tocitem" href="#Sampling-from-an-MPS"><span>Sampling from an MPS</span></a></li><li><a class="tocitem" href="#Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5"><span>Write and Read an MPS or MPO to Disk with HDF5</span></a></li></ul></li><li><a class="tocitem" href="DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../IndexType.html">Index</a></li><li><a class="tocitem" href="../IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="../ITensorType.html">ITensor</a></li><li><a class="tocitem" href="../MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="../QN.html">QN</a></li><li><a class="tocitem" href="../SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="../IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DMRG.html">DMRG</a></li><li><a class="tocitem" href="../Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="../ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="../ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="../Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="../DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="../OpSum.html">OpSum (AutoMPO)</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="../faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="../faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="../faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="../faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="../faq/JuliaPkg.html">Julia Package Manager FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="../UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="../Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced usage guide</span><ul><li><a class="tocitem" href="../AdvancedUsageGuide.html">Advanced usage guide</a></li><li><a class="tocitem" href="../Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="../QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="../CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="../ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="../HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Code Examples</a></li><li class="is-active"><a href="MPSandMPO.html">MPS and MPO Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="MPSandMPO.html">MPS and MPO Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/master/docs/src/examples/MPSandMPO.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPS-and-MPO-Examples"><a class="docs-heading-anchor" href="#MPS-and-MPO-Examples">MPS and MPO Examples</a><a id="MPS-and-MPO-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#MPS-and-MPO-Examples" title="Permalink"></a></h1><p>The following examples demonstrate operations available in ITensor to work with <a href="http://tensornetwork.org/mps/">matrix product state (MPS)</a> (or tensor train) and matrix product operator (MPO) tensor networks.</p><h2 id="Creating-an-MPS-from-a-Tensor"><a class="docs-heading-anchor" href="#Creating-an-MPS-from-a-Tensor">Creating an MPS from a Tensor</a><a id="Creating-an-MPS-from-a-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-MPS-from-a-Tensor" title="Permalink"></a></h2><p><img src="mps_from_tensor.png" alt/></p><p>A matrix product state (MPS) made of N tensors, each with one site or physical index, is a way of representing a single tensor with N indices. One way of obtaining the MPS form of an N-index tensor <code>T</code> is by repeatedly factorizing <code>T</code> into N  separate tensors using a factorization such as the <a href="ITensor.html#Singular-Value-Decomposition">Singular Value Decomposition</a> (SVD).  This algorithm for obtaining an MPS is known in the mathematics literature as the &quot;tensor train SVD&quot; or &quot;TT-SVD&quot; algorithm.</p><p>To turn an N-index (order-N) tensor T into an MPS, you can just construct an MPS by passing T as the first argument, along with keyword arguments that control the approximations used in factorizing T. Let&#39;s look at a few specific cases.</p><h4 id="ITensor-to-MPS-Example"><a class="docs-heading-anchor" href="#ITensor-to-MPS-Example">ITensor to MPS Example</a><a id="ITensor-to-MPS-Example-1"></a><a class="docs-heading-anchor-permalink" href="#ITensor-to-MPS-Example" title="Permalink"></a></h4><p>If you have a tensor <code>T</code> which is an ITensor and has indices <code>i,j,k,l,m</code>, you can create an MPS approximation of <code>T</code> where the MPS has site indices <code>i,j,k,l,m</code> as follows:</p><pre><code class="language-julia">cutoff = 1E-8
maxdim = 10
T = randomITensor(i,j,k,l,m)
M = MPS(T,(i,j,k,l,m);cutoff=cutoff,maxdim=maxdim)</code></pre><p>Here we used a random ITensor for illustrative purposes, but it could be any ITensor and typically tensors with additional structure are more well approximated by MPS.</p><h4 id="Julia-Tensor-to-MPS-Example"><a class="docs-heading-anchor" href="#Julia-Tensor-to-MPS-Example">Julia Tensor to MPS Example</a><a id="Julia-Tensor-to-MPS-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Tensor-to-MPS-Example" title="Permalink"></a></h4><p>Another situation could be where you have a Julia array or Julia tensor of dimension <span>$d^N$</span> and want to approximate it as an MPS with <span>$N$</span> site indices, each of dimension <span>$d$</span>. For example, we could have the following random Julia array of dimension <span>$2\times 2\times 2 \times 2 \times 2$</span>:</p><pre><code class="language-julia">d = 2
N = 5
A = randn(d,d,d,d,d)</code></pre><p>Alternatively, the array could be just a one dimensional array of length <span>$d^N$</span>:</p><pre><code class="language-julia">A = randn(d^N)</code></pre><p>To convert this array to an MPS, we will first need a collection of Index objects to use as the site indices of the MPS. We can conveniently construct an array of four indices of dimension 2 as follows:</p><pre><code class="language-julia">sites = siteinds(d,N)</code></pre><p>Finally, we can pass our array <code>A</code> and our <code>sites</code> to the MPS constructor along with parameters controlling the truncation level of the factorizations used:</p><pre><code class="language-julia">cutoff = 1E-8
maxdim = 10
M = MPS(A,sites;cutoff=cutoff,maxdim=maxdim)</code></pre><h2 id="Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS"><a class="docs-heading-anchor" href="#Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS">Obtaining Elements of a Tensor Represented by an MPS</a><a id="Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS" title="Permalink"></a></h2><p>A matrix product state (MPS) or tensor train (TT) is a format for representing a large tensor having N indices in terms of N smaller tensors. Given an MPS represeting a tensor T we can obtain a particular element <span>$T^{s_1 s_2 s_3 \cdots s_N}$</span> of that tensor using code similar to the following code below.</p><p>In the example code below we will obtain the element <span>$T^{1,2,1,1,2,1,2,2,2,1}$</span> of the tensor T which is (implicitly) defined by the MPS psi:</p><pre><code class="language-julia">N = 10
s = siteinds(2,N)
chi = 4
psi = randomMPS(s;linkdims=chi)

# Make an array of integers of the element we
# want to obtain
el = [1,2,1,1,2,1,2,2,2,1]

V = ITensor(1.)
for j=1:N
  V *= (psi[j]*state(s[j],el[j]))
end
v = scalar(V)

# v is the element we wanted to obtain:
@show v</code></pre><pre class="documenter-example-output">-0.019917557905909915</pre><p>The call to <code>state(s[j],el[j])</code> in the code above makes a single-index ITensor with the Index <code>s[j]</code> and the entry at location <code>el[j]</code> set to 1.0, with all other  entries set to 0.0. Contracting this tensor with the MPS tensor at site <code>j</code>  can be viewed as &quot;clamping&quot; or &quot;fixing&quot; the index to a set value. The resulting tensors are contracted sequentially, overwriting the ITensor <code>V</code>, and the final scalar value of <code>V</code> is the tensor element we seek.</p><p>See below for a visual depiction of what the above code is doing:</p><p><img src="mps_element.png" alt/></p><h2 id="Expected-Value-of-Local-Operators"><a class="docs-heading-anchor" href="#Expected-Value-of-Local-Operators">Expected Value of Local Operators</a><a id="Expected-Value-of-Local-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-Value-of-Local-Operators" title="Permalink"></a></h2><p>When using an MPS to represent a quantum wavefunction <span>$|\psi\rangle$</span> a common operation is computed the expected value <span>$\langle\psi|\hat{A}_j|\psi\rangle$</span> of a local operator <span>$\hat{A}_j$</span> acting on site <span>$j$</span>. This can be accomplished efficiently and conveniently using the <a href="../MPSandMPO.html#ITensors.expect-Tuple{MPS, Any}"><code>expect</code></a> function as:</p><pre><code class="language-julia">Avals = expect(psi,&quot;A&quot;)</code></pre><p>where <code>&quot;A&quot;</code> must be an operator associated with the physical site type, or site tags, of the sites of the MPS <code>psi</code>. For example, the operator name could be  <code>&quot;Sz&quot;</code> for spin sites or <code>&quot;Ntot&quot;</code> for electron sites. (For more information about defining such operators yourself, see the section on <a href="Physics.html#Extending-an-Existing-Local-Hilbert-Space">Extending an Existing Local Hilbert Space</a>.)</p><p>As a concrete example, consider computing the expectation value of <span>$S^z_j$</span> on every site of an MPS representing a system of N spins of size <span>$S=1/2$</span>. In the following example we will use a random MPS of bond dimension <span>$\chi=4$</span> but the MPS could be obtained other ways such as through a DMRG calculation.</p><pre><code class="language-julia">N = 10
chi = 4
sites = siteinds(&quot;S=1/2&quot;,N)
psi = randomMPS(sites,chi)
magz = expect(psi,&quot;Sz&quot;)
for (j,mz) in enumerate(magz)
    println(&quot;$j $mz&quot;)
end</code></pre><pre class="documenter-example-output">1 0.24369905261193509
2 0.040193302438189776
3 0.06989794873203688
4 0.053321036125421745
5 0.09905337900884659
6 0.06619546112314964
7 -0.10188858007257158
8 -0.1418015653278337
9 -0.11100990697121824
10 0.0040695279707346375</pre><p><img src="mps_expect.png" alt/></p><h2 id="Computing-Correlation-Functions"><a class="docs-heading-anchor" href="#Computing-Correlation-Functions">Computing Correlation Functions</a><a id="Computing-Correlation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Correlation-Functions" title="Permalink"></a></h2><p>In addition to expected values of local operators discussed above, another type of observable that is very important in physics studies are correlation functions of the form</p><p class="math-container">\[C_{ij} = \langle\psi| A_i B_j |\psi\rangle\]</p><p>These can be computed efficiently for an MPS <code>psi</code> in ITensor using the <a href="../MPSandMPO.html#ITensors.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}"><code>correlation_matrix</code></a> function:</p><pre><code class="language-julia">C = correlation_matrix(psi,&quot;A&quot;,&quot;B&quot;)</code></pre><p>where <code>&quot;A&quot;</code> and <code>&quot;B&quot;</code> must be an operator names associated with the physical site type,  or site tags, of the sites of the MPS <code>psi</code>. For example, these strings could be  <code>&quot;Sz&quot;</code>, <code>&quot;S+&quot;</code>, or <code>&quot;S-&quot;</code> for spin sites, or <code>&quot;Cdagup&quot;</code> and <code>&quot;Cup&quot;</code> for electron sites. (For more information about defining such operators yourself, see the section on <a href="Physics.html#Extending-an-Existing-Local-Hilbert-Space">Extending an Existing Local Hilbert Space</a>.)</p><p>As a concrete example, say we have an MPS <code>psi</code> for a system of spins and  want to compute the correlator <span>$\langle\psi|S^z_i S^z_j|\psi\rangle$</span>. We can compute this as:</p><pre><code class="language-julia">zzcorr = correlation_matrix(psi,&quot;Sz&quot;,&quot;Sz&quot;)</code></pre><p><img src="mps_zz_correlation.png" alt/></p><p>See the <a href="../MPSandMPO.html#ITensors.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}"><code>correlation_matrix</code></a> docs for more details about additional arguments you can pass to this function.</p><h2 id="Applying-a-Single-site-Operator-to-an-MPS"><a class="docs-heading-anchor" href="#Applying-a-Single-site-Operator-to-an-MPS">Applying a Single-site Operator to an MPS</a><a id="Applying-a-Single-site-Operator-to-an-MPS-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-a-Single-site-Operator-to-an-MPS" title="Permalink"></a></h2><p>In many applications one needs to modify a matrix product  state (MPS) by multiplying it with an operator that acts  only on a single site. This is actually a very straightforward operation and this formula shows you how to do it in ITensor.</p><p>Say we have an operator <span>$G^{s&#39;_3}_{s_3}$</span> which which acts non-trivially on site 3 of our MPS <code>psi</code> as in the following diagram:</p><p><img src="mps_onesite_figures/operator_app_mps.png" alt/></p><p>To carry out this operation, contract the operator G with the MPS tensor for site 3, removing the prime from the <span>$s&#39;_3$</span> index afterward:</p><p><img src="mps_onesite_figures/operator_contract.png" alt/></p><pre><code class="language-julia">newA = G * psi[3]
noprime!(newA)</code></pre><p>Finally, put the new tensor back into MPS <code>psi</code> to update its third MPS tensor:</p><pre><code class="language-julia">psi[3] = newA</code></pre><p>Afterward, we can visualize the modified MPS as:</p><p><img src="mps_onesite_figures/updated_mps.png" alt/></p><p>As a technical note, if you are working in a context where gauge or orthogonality properties of the MPS are important, such as in time evolution using two-site gates,  then you may want to call <code>orthogonalize!(psi,3)</code> before modifying the tensor at site 3, which will ensure that the MPS remains in a  well-defined orthogonal gauge centered on site 3. Modifying a tensor which is left- or right-orthogonal (i.e. not the &quot;center&quot; tensor of the gauge) will destroy the gauge condition and  require extra operations to restore it. (Calling <code>orthogonalize!</code> method will automatically fix this but will have to do extra work to do so.)</p><h2 id="Applying-a-Two-site-Operator-to-an-MPS"><a class="docs-heading-anchor" href="#Applying-a-Two-site-Operator-to-an-MPS">Applying a Two-site Operator to an MPS</a><a id="Applying-a-Two-site-Operator-to-an-MPS-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-a-Two-site-Operator-to-an-MPS" title="Permalink"></a></h2><p>A very common operation with matrix product states (MPS) is  multiplication by a two-site operator or &quot;gate&quot; which modifies  the MPS. This procedure can be carried out in an efficient,  controlled way which is adaptive in the MPS bond dimension.</p><p>Say we have an operator <span>$G^{s&#39;_3 s&#39;_4}_{s_3 s_4}$</span> which is our gate and which acts on physical sites 3 and 4 of our MPS <code>psi</code>, as in the following diagram:</p><p><img src="twosite_figures/gate_app_mps.png" alt/></p><p>To apply this gate in a controlled manner, first &#39;gauge&#39; the MPS <code>psi</code> such that either site 3 or 4 is the <em>orthogonality center</em>. Here we make site 3 the center:</p><pre><code class="language-julia">orthogonalize!(psi,3)</code></pre><p><img src="twosite_figures/gate_gauge.png" alt/></p><p>The other MPS tensors are now either left-orthogonal or right-orthogonal and can be left out of further steps without producing incorrect results.</p><p>Next, contract the gate tensor G with the MPS tensors for sites 3 and 4</p><p><img src="twosite_figures/gate_contract.png" alt/></p><pre><code class="language-julia">wf = (psi[3] * psi[4]) * G
noprime!(wf)</code></pre><p>Finally, use the singular value decomposition (SVD) to factorize the resulting tensor, multiplying the singular values into either U or V. Assign these two tensors back into the MPS to update it.</p><p><img src="twosite_figures/gate_svd.png" alt/></p><pre><code class="language-julia">inds3 = uniqueinds(psi[3],psi[4])
U,S,V = svd(wf,inds3,cutoff=1E-8)
psi[3] = U
psi[4] = S*V</code></pre><p>The call to <code>uniqueinds(psi[3])</code> analyzes the indices of <code>psi[3]</code> and <code>psi[4]</code>  and finds any which are unique to just <code>psi[3]</code>, saving this collection of indices as <code>inds3</code>. Passing this collection of indices to the <code>svd</code> function tells it to treat any indices  that are unique to <code>psi[3]</code> as the indices which should go onto the <code>U</code> tensor afterward. We also set a truncation error cutoff of 1E-8 in the call to <code>svd</code> to truncate  the smallest singular values and control the size of the resulting MPS. Other cutoff values can be used, depending on the desired accuracy, as well as limits on the maximum bond dimension (<code>maxdim</code> keyword argument).</p><p><strong>Complete code example</strong></p><pre><code class="language-julia">orthogonalize!(psi,3)

wf = (psi[3] * psi[4]) * G
noprime!(wf)

inds3 = uniqueinds(psi[3],psi[4])
U,S,V = svd(wf,inds3,cutoff=1E-8)
psi[3] = U
psi[4] = S*V</code></pre><h2 id="Computing-the-Entanglement-Entropy-of-an-MPS"><a class="docs-heading-anchor" href="#Computing-the-Entanglement-Entropy-of-an-MPS">Computing the Entanglement Entropy of an MPS</a><a id="Computing-the-Entanglement-Entropy-of-an-MPS-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Entanglement-Entropy-of-an-MPS" title="Permalink"></a></h2><p>A key advantage of using the matrix product state (MPS) format to represent quantum wavefunctions is that it allows one to efficiently compute the entanglement entropy of any left-right bipartition of the system in one dimension, or for a two-dimensional system any &quot;cut&quot; along the MPS path.</p><p>Say that we have obtained an MPS <code>psi</code> of length N and we wish to compute the entanglement entropy of a bipartition of the system into a region &quot;A&quot; which consists of sites 1,2,...,b and a region B consisting of sites b+1,b+2,...,N.</p><p>Then the following code formula can be used to accomplish this task:</p><pre><code class="language-julia">orthogonalize!(psi, b)
U,S,V = svd(psi[b], (linkind(psi, b-1), siteind(psi,b)))
SvN = 0.0
for n=1:dim(S, 1)
  p = S[n,n]^2
  SvN -= p * log(p)
end</code></pre><p>As a brief explanation of the code above, the call to <code>orthogonalize!(psi,b)</code> shifts the orthogonality center to site <code>b</code> of the MPS. </p><p>The call to the <code>svd</code> routine says to treat the link (virtual or bond) Index connecting the b&#39;th MPS tensor <code>psi[b]</code> and the b&#39;th physical Index as &quot;row&quot; indices for the purposes of the SVD (these indices will end up on <code>U</code>, along with the Index connecting <code>U</code> to <code>S</code>).</p><p>The code in the <code>for</code> loop iterates over the diagonal elements of the <code>S</code> tensor (which are the singular values from the SVD), computes their squares to obtain the probabilities of observing the various states in the Schmidt basis (i.e. eigenvectors of the left-right bipartition reduced density matrices), and puts them into the von Neumann entanglement entropy formula <span>$S_\text{vN} = - \sum_{n} p_{n} \log{p_{n}}$</span>.</p><h2 id="Sampling-from-an-MPS"><a class="docs-heading-anchor" href="#Sampling-from-an-MPS">Sampling from an MPS</a><a id="Sampling-from-an-MPS-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-an-MPS" title="Permalink"></a></h2><p>A matrix product state (MPS) can be viewed as defining a probability distribution  through the Born rule, as is the case when the MPS represents a quantum wavefunction.  To sample from the distribution defined by an MPS, you can use the function <code>sample</code> provided in ITensor. For an MPS <code>psi</code> call to <code>sample(psi)</code> returns a random sample from the distribution defined by <code>psi</code>. (Note that each sample is drawn anew and not from a Markov chain seeded by a previous sample; this is possible because  the algorithm for sampling MPS is a `perfect&#39; sampling algorithm with no autocorrelation.)</p><p>In more detail, say we have a set of <code>N</code> site indices <code>s</code> and define a random MPS with these sites:</p><pre><code class="language-julia">N = 10 # number of sites
d = 3  # dimension of each site
chi = 16 # bond dimension of the MPS
s = siteinds(d,N)
psi = randomMPS(s;linkdims=chi)</code></pre><p>We can now draw some samples from this MPS as</p><pre><code class="language-julia">v1 = sample(psi)
v2 = sample(psi)
v3 = sample(psi)
println(v1)
println(v2)
println(v3)</code></pre><pre class="documenter-example-output">[1, 1, 3, 2, 3, 2, 3, 3, 1, 1]
[1, 1, 3, 3, 1, 1, 1, 1, 2, 3]
[1, 2, 3, 2, 3, 1, 3, 1, 1, 1]</pre><p>The integers in each of the samples represent settings of each of the MPS indices in the &quot;computational basis&quot;.</p><p>For reasons of efficiency, the <code>sample</code> function requires the MPS to be in orthogonal form, orthogonalized to the first site. If it is not already in this form, it can be brought into orthogonal form by calling <code>orthogonalize!(psi,1)</code>.</p><h2 id="Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5"><a class="docs-heading-anchor" href="#Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5">Write and Read an MPS or MPO to Disk with HDF5</a><a id="Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5-1"></a><a class="docs-heading-anchor-permalink" href="#Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5" title="Permalink"></a></h2><p><strong>Writing an MPS to an HDF5 File</strong></p><p>Let&#39;s say you have an MPS <code>psi</code> which you have made or obtained from a calculation. To write it to an HDF5 file named &quot;myfile.h5&quot; you can use the following pattern:</p><pre><code class="language-julia">using ITensors.HDF5
f = h5open(&quot;myfile.h5&quot;,&quot;w&quot;)
write(f,&quot;psi&quot;,psi)
close(f)</code></pre><p>Above, the string &quot;psi&quot; can actually be any string you want such as &quot;MPS psi&quot; or &quot;Result MPS&quot; and doesn&#39;t have to have the same name as the reference <code>psi</code>. Closing the file <code>f</code> is optional and you can also write other objects to the same file before closing it.</p><p>[<em>Above we did <code>using ITensors.HDF5</code> since HDF5 is already included as a dependency with ITensor. You can also do <code>using HDF5</code> but must add the HDF5 package beforehand for that to work.</em>]</p><p><strong>Reading an MPS from an HDF5 File</strong></p><p>Say you have an HDF5 file &quot;myfile.h5&quot; which contains an MPS stored as a dataset with the name &quot;psi&quot;. (Which would be the situation if you wrote it as in the example above.) To read this ITensor back from the HDF5 file, use the following pattern:</p><pre><code class="language-julia">using ITensors.HDF5
f = h5open(&quot;myfile.h5&quot;,&quot;r&quot;)
psi = read(f,&quot;psi&quot;,MPS)
close(f)</code></pre><p>Many functions which involve MPS, such as the <code>dmrg</code> function or the <code>OpSum</code> system require that you use an array of site indices which match the MPS. So when reading in an MPS from disk, do not construct a new array of site indices. Instead, you can obtain them like this: <code>sites = siteinds(psi)</code>.</p><p>So for example, to create an MPO from an OpSum which has the same site indices as your MPS <code>psi</code>, do the following:</p><pre><code class="language-julia">ampo = OpSum()
# Then put operators into ampo...

sites = siteinds(psi) # Get site indices from your MPS
H = MPO(ampo,sites)

# Compute &lt;psi|H|psi&gt;
energy_psi = inner(psi&#39;,H,psi)</code></pre><p>Note the <code>MPS</code> argument to the read function, which tells Julia which read function to call and how to interpret the data stored in the HDF5 dataset named &quot;psi&quot;. In the  future we might lift the requirement of providing the type and have it be detected automatically from the data stored in the file.</p><p><strong>Writing and Reading MPOs</strong></p><p>To write or read MPOs to or from HDF5 files, just follow the examples above but use the type <code>MPO</code> when reading an MPO from the file instead of the type <code>MPS</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ITensor.html">« ITensor Examples</a><a class="docs-footer-nextpage" href="DMRG.html">DMRG Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Thursday 21 July 2022 20:30">Thursday 21 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
