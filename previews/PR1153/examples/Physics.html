<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Physics (SiteType) System Examples · ITensors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ITensors.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="../getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="../getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="../getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="../getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="../tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="../tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="DMRG.html">DMRG Examples</a></li><li class="is-active"><a class="tocitem" href="Physics.html">Physics (SiteType) System Examples</a><ul class="internal"><li><a class="tocitem" href="#Obtaining-a-Predefined-Operator"><span>Obtaining a Predefined Operator</span></a></li><li><a class="tocitem" href="#Make-a-Custom-Operator-from-a-Matrix"><span>Make a Custom Operator from a Matrix</span></a></li><li><a class="tocitem" href="#custom_op"><span>Making a Custom op Definition</span></a></li><li><a class="tocitem" href="#Making-a-Custom-state-Definition"><span>Making a Custom state Definition</span></a></li><li><a class="tocitem" href="#Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom"><span>Make a Custom Local Hilbert Space / Physical Degree of Freedom</span></a></li><li><a class="tocitem" href="#Make-a-Custom-Local-Hilbert-Space-with-QNs"><span>Make a Custom Local Hilbert Space with QNs</span></a></li></ul></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../IndexType.html">Index</a></li><li><a class="tocitem" href="../IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="../ITensorType.html">ITensor</a></li><li><a class="tocitem" href="../MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="../QN.html">QN</a></li><li><a class="tocitem" href="../SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="../IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DMRG.html">DMRG</a></li><li><a class="tocitem" href="../Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="../ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="../ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="../Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="../DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="../OpSum.html">OpSum (AutoMPO)</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="../faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="../faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="../faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="../faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="../faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="../faq/JuliaPkg.html">Julia Package Manager FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="../UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="../Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="../AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="../Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="../QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="../CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="../ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="../HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="../DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Code Examples</a></li><li class="is-active"><a href="Physics.html">Physics (SiteType) System Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Physics.html">Physics (SiteType) System Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/examples/Physics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Physics-(SiteType)-System-Examples"><a class="docs-heading-anchor" href="#Physics-(SiteType)-System-Examples">Physics (SiteType) System Examples</a><a id="Physics-(SiteType)-System-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-(SiteType)-System-Examples" title="Permalink"></a></h1><h2 id="Obtaining-a-Predefined-Operator"><a class="docs-heading-anchor" href="#Obtaining-a-Predefined-Operator">Obtaining a Predefined Operator</a><a id="Obtaining-a-Predefined-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-a-Predefined-Operator" title="Permalink"></a></h2><p>Given an Index carrying a &quot;physical&quot; tag such as &quot;Qubit&quot;, &quot;S=1/2&quot;, &quot;Boson&quot;, etc. there are a set of pre-defined operators for each tag. The entire set of operators can be found in the section <a href="../IncludedSiteTypes.html#SiteTypes-Included-with-ITensor">SiteTypes Included with ITensor</a>.</p><p>If you have an Index <code>s</code> carrying a &quot;S=1/2&quot; tag, for example, you can obtain the &quot;Sz&quot; operator like this:</p><pre><code class="language-julia hljs">op(&quot;Sz&quot;,s)</code></pre><p>Usually indices with physical tags come from an array of indices returned from the <code>siteinds</code> function</p><pre><code class="language-julia hljs">sites = siteinds(&quot;S=1/2&quot;,N)</code></pre><p>in which case one might want the &quot;Sz&quot; operator on site 4</p><pre><code class="language-julia hljs">Sz4 = op(&quot;Sz&quot;,sites[4])</code></pre><h2 id="Make-a-Custom-Operator-from-a-Matrix"><a class="docs-heading-anchor" href="#Make-a-Custom-Operator-from-a-Matrix">Make a Custom Operator from a Matrix</a><a id="Make-a-Custom-Operator-from-a-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Make-a-Custom-Operator-from-a-Matrix" title="Permalink"></a></h2><p>The <code>op</code> function can be passed any matrix, as long as it has the correct dimensions, and it will make this into an ITensor representing the operator with the corresponding matrix elements.</p><p>For example, if we have a two-dimensional Index <code>s</code> we could make the &quot;Sz&quot; operator ourselves from the matrix</p><pre><code class="language-julia hljs">M = [1/2 0 ; 0 -1/2]</code></pre><p>by calling</p><pre><code class="language-julia hljs">Sz = op(M,s)</code></pre><h2 id="custom_op"><a class="docs-heading-anchor" href="#custom_op">Making a Custom op Definition</a><a id="custom_op-1"></a><a class="docs-heading-anchor-permalink" href="#custom_op" title="Permalink"></a></h2><p>The function <code>op</code> is used to obtain operators defined for a  given &quot;site type&quot;. ITensor includes pre-defined site types such as &quot;S=1/2&quot;, &quot;S=1&quot;, &quot;Electron&quot; and others. Or you can define your own site type as discussed in detail in the code examples further below.</p><p><strong>Extending op Function Definitions</strong></p><p>Perhaps the most common part of the site type system one wishes to extend are the various <code>op</code> or <code>op!</code> function overloads which allow code like</p><pre><code class="language-julia hljs">s = siteind(&quot;S=1/2&quot;)
Sz = op(&quot;Sz&quot;,s)</code></pre><p>to automatically create the <span>$S^z$</span> operator for an Index <code>s</code> based on the  <code>&quot;S=1/2&quot;</code> tag it carries. A major reason to define such <code>op</code> overloads is to allow the OpSum system to recognize new operator names, as discussed more below.</p><p>Let&#39;s see how to introduce a new operator name into the ITensor site type system for this existing site type of <code>&quot;S=1/2&quot;</code>. The operator we will introduce is the projector onto the up spin state <span>$P_\uparrow$</span> which we will denote with the string <code>&quot;Pup&quot;</code>. </p><p>As a matrix acting on the space <span>$\{ |\!\uparrow\rangle, |\!\downarrow\rangle \}$</span>, the <span>$P_\uparrow$</span> operator is given by</p><p class="math-container">\[\begin{aligned}

P_\uparrow &amp;= 
\begin{bmatrix}
 1 &amp;  0 \\
 0  &amp; 0 \\
\end{bmatrix}

\end{aligned}\]</p><p>To add this operator to the ITensor <code>op</code> system, we just need to introduce the following code</p><pre><code class="language-julia hljs">using ITensors

ITensors.op(::OpName&quot;Pup&quot;,::SiteType&quot;S=1/2&quot;) =
 [1 0
  0 0]</code></pre><p>This code can be defined anywhere, such as in your own personal application code and does  not have to be put into the ITensor library source code.</p><p>Note that we have to name the function <code>ITensors.op</code> and not just <code>op</code> so that it overloads other functions of the name <code>op</code> inside the ITensors module. </p><p>Having defined the above code, we can now do things like</p><pre><code class="language-julia hljs">s = siteind(&quot;S=1/2&quot;)
Pup = op(&quot;Pup&quot;,s)</code></pre><p>to obtain the <code>&quot;Pup&quot;</code> operator for our <code>&quot;S=1/2&quot;</code> Index <code>s</code>. Or we can do a similar thing for an array of site indices:</p><pre><code class="language-julia hljs">N = 40
s = siteinds(&quot;S=1/2&quot;,N)
Pup1 = op(&quot;Pup&quot;,s[1])
Pup3 = op(&quot;Pup&quot;,s[3])</code></pre><p>Note that for the <code>&quot;Qudit&quot;</code>/<code>&quot;Boson&quot;</code> site types, you have to define your overload of <code>op</code> with the dimension of the local Hilbert space, for example:</p><pre><code class="language-julia hljs">using ITensors

function ITensors.op(::OpName&quot;P1&quot;, ::SiteType&quot;Boson&quot;, d::Int)
  o = zeros(d, d)
  o[1, 1] = 1
  return o
end</code></pre><p>Alternatively you could use Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-comprehensions">array comprehension</a> syntax:</p><pre><code class="language-julia hljs">ITensors.op(::OpName&quot;P1&quot;, ::SiteType&quot;Boson&quot;, d::Int) =
  [(i == j == 1) ? 1.0 : 0.0 for i in 1:d, j in 1:d]</code></pre><p><strong>Using Custom Operators in OpSum</strong></p><p>A key use of these <code>op</code> system extensions is allowing additional operator names to be recognized by the OpSum system for constructing matrix product operator (MPO) tensor networks. With the code above defining the <code>&quot;Pup&quot;</code> operator, we are now  allowed to use this operator name in any OpSum code involving <code>&quot;S=1/2&quot;</code> site  indices.</p><p>For example, we could now make an OpSum involving our custom operator such as:</p><pre><code class="language-julia hljs">N = 100
sites = siteinds(&quot;S=1/2&quot;,N)
os = OpSum()
for n=1:N
  os += &quot;Pup&quot;,n
end
P = MPO(os,sites)</code></pre><p>This code makes an MPO <code>P</code> which is just the sum of a spin-up projection operator acting on every site.</p><h2 id="Making-a-Custom-state-Definition"><a class="docs-heading-anchor" href="#Making-a-Custom-state-Definition">Making a Custom state Definition</a><a id="Making-a-Custom-state-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-Custom-state-Definition" title="Permalink"></a></h2><p>The function <code>state</code> is used to define states (single-site wavefunctions) that sites can be in. For example, the &quot;Qubit&quot; site type includes  definitions for the &quot;0&quot; and &quot;1&quot; states as well as the &quot;+&quot; (eigenstate of X operator) state. The &quot;S=1/2&quot; site type includes definitions for the &quot;Up&quot; and &quot;Dn&quot; (down) states.</p><p>Say we want to define a new state for the &quot;Electron&quot; site type called &quot;+&quot;, which has the meaning of one electron with its spin in the +X direction. First let&#39;s review the existing state definitions:</p><pre><code class="language-julia hljs">ITensors.state(::StateName&quot;Emp&quot;, ::SiteType&quot;Electron&quot;) = [1.0, 0, 0, 0]
ITensors.state(::StateName&quot;Up&quot;, ::SiteType&quot;Electron&quot;) = [0.0, 1, 0, 0]
ITensors.state(::StateName&quot;Dn&quot;, ::SiteType&quot;Electron&quot;) = [0.0, 0, 1, 0]
ITensors.state(::StateName&quot;UpDn&quot;, ::SiteType&quot;Electron&quot;) = [0.0, 0, 0, 1]</code></pre><p>As we can see, the four settings of an &quot;Electron&quot; index correspond to the states <span>$|0\rangle, |\uparrow\rangle, |\downarrow\rangle, |\uparrow\downarrow\rangle$</span>.</p><p>So we can define our new state &quot;+&quot; as follows:</p><pre><code class="language-julia hljs">ITensors.state(::StateName&quot;+&quot;, ::SiteType&quot;Electron&quot;) = [0, 1/sqrt(2), 1/sqrt(2), 0]</code></pre><p>which makes the state</p><p class="math-container">\[|+\rangle = \frac{1}{\sqrt{2}} |\uparrow\rangle + \frac{1}{\sqrt{2}} |\downarrow\rangle\]</p><p>Having defined this overload of <code>state</code>, if we have an Index of type &quot;Electron&quot; we can obtain our new state for it by doing</p><pre><code class="language-julia hljs">s = siteind(&quot;Electron&quot;)
plus = state(&quot;+&quot;,s)</code></pre><p>We can also use this new state definition in other ITensor features such as  the MPS constructor taking an array of state names.</p><h2 id="Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom"><a class="docs-heading-anchor" href="#Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom">Make a Custom Local Hilbert Space / Physical Degree of Freedom</a><a id="Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom-1"></a><a class="docs-heading-anchor-permalink" href="#Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom" title="Permalink"></a></h2><p>ITensor provides support for a range of common local Hilbert space types,  or physical degrees of freedom, such as S=1/2 and S=1 spins; spinless and spinful fermions; and more.</p><p>However, there can be many cases where you need to make custom degrees of freedom. You might be working with an exotic system, such as <span>$Z_N$</span> parafermions for example, or need to customize other defaults provided by ITensor.</p><p>In ITensor, such a customization is done by overloading functions on specially designated Index tags.  Below we give an brief introduction by example of how to make such custom Index site types in ITensor.  Other code formulas following this one explain how to build on this example to expand the capabilities of your custom site type such as adding support for quantum number (QN) conservation and defining custom mappings of strings to states.</p><p>Throughout we will focus on the example of <span>$S=3/2$</span> spins. These are spins taking the <span>$S^z$</span> values of <span>$+3/2,+1/2,-1/2,-3/2$</span>. So as tensor indices, they are indices of dimension 4.</p><p>The key operators we will make for this example are <span>$S^z$</span>, <span>$S^+$</span>, and <span>$S^-$</span>, which are defined as:</p><p class="math-container">\[\begin{aligned}
S^z &amp;= 
\begin{bmatrix}
3/2 &amp;  0  &amp;  0  &amp;  0 \\
 0  &amp; 1/2 &amp;  0  &amp;  0 \\
 0  &amp;  0  &amp;-1/2 &amp;  0 \\
 0  &amp;  0  &amp;  0  &amp;-3/2\\
\end{bmatrix} \\

S^+ &amp; = 
\begin{bmatrix}
 0  &amp;  \sqrt{3}  &amp;  0  &amp;  0 \\
 0  &amp;  0  &amp;  2  &amp;  0 \\
 0  &amp;  0  &amp;  0  &amp;  \sqrt{3} \\
 0  &amp;  0  &amp;  0  &amp;  0 \\
\end{bmatrix} \\

S^- &amp; = 
\begin{bmatrix}
 0  &amp;  0 &amp;  0  &amp;  0 \\
 \sqrt{3}  &amp;  0  &amp;  0  &amp;  0 \\
 0  &amp;  2  &amp;  0  &amp;  0  \\
 0  &amp;  0  &amp;  \sqrt{3}  &amp;  0 \\
\end{bmatrix} \\
\end{aligned}\]</p><p><strong>Code Preview</strong></p><p>First let&#39;s see the minimal code needed to define and use this new <span>$S=3/2$</span> site type, then we will discuss what each part of the code is doing.</p><pre><code class="language-julia hljs">using ITensors

ITensors.space(::SiteType&quot;S=3/2&quot;) = 4

ITensors.op(::OpName&quot;Sz&quot;,::SiteType&quot;S=3/2&quot;) =
  [+3/2   0    0    0
     0  +1/2   0    0 
     0    0  -1/2   0
     0    0    0  -3/2]

ITensors.op(::OpName&quot;S+&quot;,::SiteType&quot;S=3/2&quot;) =
  [0  √3  0  0
   0   0  2  0
   0   0  0 √3
   0   0  0  0] 

ITensors.op(::OpName&quot;S-&quot;,::SiteType&quot;S=3/2&quot;) =
  [0   0  0   0
   √3  0  0   0
   0   2  0   0
   0   0  √3  0] 
</code></pre><p>Now let&#39;s look at each part of the code above.</p><p><strong>The SiteType</strong></p><p>The most important aspect of this code is a special type, known as a <code>SiteType</code>, which is a type made from a string. The string of interest here will be an Index tag. In the code above, the <code>SiteType</code> we are using is</p><pre><code class="language-julia hljs">SiteType&quot;S=3/2&quot;</code></pre><p>What is the purpose of a <code>SiteType</code>? The answer is that we would like to be  able to select different functions to call on an ITensor Index based on what tags it has, but that is not directly possible in Julia or indeed most languages.  However, if we can map a tag to a type in the Julia type system, we can create function overloads for that type. ITensor does this for certain functions for you, and we will discuss a few of these functions below. So if the code encounters an Index such as <code>Index(4,&quot;S=3/2&quot;)</code> it can  call these functions which are specialized for indices carrying the <code>&quot;S=3/2&quot;</code> tag. </p><p><strong>The space Function</strong></p><p>One of the overloadable <code>SiteType</code> functions is <code>space</code>, whose job is to  describe the vector space corresponding to that site type. For our <code>SiteType&quot;S=3/2&quot;</code> overload of <code>space</code>, which gets called for any Index  carrying the <code>&quot;S=3/2&quot;</code> tag, the definition is</p><pre><code class="language-julia hljs">ITensors.space(::SiteType&quot;S=3/2&quot;) = 4</code></pre><p>Note that the function name is prepended with <code>ITensors.</code> before <code>space</code>. This prefix makes sure the function is overloading other versions of the <code>space</code> inside the <code>ITensors</code> module.</p><p>The only information needed about the vector space of a <code>&quot;S=3/2&quot;</code> Index in this example is that it is of dimension four. So the <code>space</code> function returns the integer <code>4</code>. We will see in more advanced examples that the returned value can instead be an array which specifies not only the dimension of a <code>&quot;S=3/2&quot;</code> Index, but also additional subspace structure it has corresponding to quantum numbers.</p><p>After defining this <code>space</code> function, you can just write code like:</p><pre><code class="language-julia hljs">s = siteind(&quot;S=3/2&quot;)</code></pre><p>to obtain a single <code>&quot;S=3/2&quot;</code> Index, or write code like</p><pre><code class="language-julia hljs">N = 100
sites = siteinds(&quot;S=3/2&quot;,N)</code></pre><p>to obtain an array of N <code>&quot;S=3/2&quot;</code> indices. The custom <code>space</code> function will be used to determine the dimension of these indices, and the <code>siteind</code> or <code>siteinds</code> functions provided by ITensor will help with extra things like putting other Index tags that are conventional for site indices.</p><p><strong>The op Function</strong></p><p>The <code>op</code> function lets you define custom local operators associated to the physical degrees of freedom of your <code>SiteType</code>. Then for example  you can use indices carrying your custom tag with OpSum and the  OpSum system will know how to automatically convert names of operators such as <code>&quot;Sz&quot;</code> or <code>&quot;S+&quot;</code> into ITensors so that it can make an actual MPO.</p><p>In our example above, we defined this function for the case of the <code>&quot;Sz&quot;</code> operator as:</p><pre><code class="language-julia hljs">ITensors.op(::OpName&quot;Sz&quot;,::SiteType&quot;S=3/2&quot;) =
  [+3/2   0    0    0
     0  +1/2   0    0
     0    0  -1/2   0
     0    0    0  -3/2]</code></pre><p>As you can see, the function is passed two objects: an <code>OpName</code> and a <code>SiteType</code>. The strings <code>&quot;Sz&quot;</code> and <code>&quot;S=3/2&quot;</code> are also part of the type of these objects, and  have the meaning of which operator name we are defining and which site type these operators are defined for.</p><p>The body of this overload of <code>ITensors.op</code> constructs and returns a Julia matrix which gives the matrix elements of the operator we are defining.</p><p>Once this function is defined, and if you have an Index such as</p><pre><code class="language-julia hljs">s = Index(4,&quot;S=3/2&quot;)</code></pre><p>then, for example, you can get the <code>&quot;Sz&quot;</code> operator for this Index  and print it out by doing:</p><pre><code class="language-julia hljs">Sz = op(&quot;Sz&quot;,s)
println(Sz)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ITensor ord=2
Dim 1: (dim=4|id=909|&quot;S=3/2&quot;)&#39;
Dim 2: (dim=4|id=909|&quot;S=3/2&quot;)
NDTensors.Dense{Float64, Vector{Float64}}
 4×4
 1.5  0.0   0.0   0.0
 0.0  0.5   0.0   0.0
 0.0  0.0  -0.5   0.0
 0.0  0.0   0.0  -1.5</code></pre><p>Again, through the magic of the <code>SiteType</code> system, the ITensor library takes your Index, reads off its tags,  notices that one of them is <code>&quot;S=3/2&quot;</code>, and converts this into the type  <code>SiteType&quot;S=3/2&quot;</code> in order to call the specialized function <code>ITensors.op</code> defined above.</p><p>You can use the <code>op</code> function yourself with a set of site indices created from the <code>siteinds</code> function like this:</p><pre><code class="language-julia hljs">N = 100
sites = siteinds(&quot;S=3/2&quot;,N)
Sz1 = op(&quot;Sz&quot;,sites[1])
Sp3 = op(&quot;S+&quot;,sites[3])</code></pre><p>Alternatively, you can write the lines of code above in the style of <code>Sz1 = op(&quot;Sz&quot;,sites,1)</code>.</p><p>This same <code>op</code> function is used inside of OpSum (formerly called AutoMPO)  when it converts its input into an actual MPO. So by defining custom operator names you can pass any of these operator names into OpSum and it will know how to use these operators.</p><p><strong>Further Steps</strong></p><p>See how the built-in site types are defined inside the ITensor library:</p><ul><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/spinhalf.jl">S=1/2 sites</a> - Dimension 2 local Hilbert space. Similar to the <code>&quot;Qubit&quot;</code> site type, shares many of the same operator definitions.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/qubit.jl">Qubit sites</a> - Dimension 2 local Hilbert space. Similar to the <code>&quot;S=1/2&quot;</code> site type, shares many of the same operator definitions.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/spinone.jl">S=1 sites</a> - Dimension 3 local Hilbert space.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/fermion.jl">Fermion sites</a> - Dimension 2 local Hilbert space. Spinless fermion site type.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/electron.jl">Electron sites</a> - Dimension 4 local Hilbert space. Spinfull fermion site type.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/tj.jl">tJ sites</a> - Dimension 3 local Hilbert space. Spinfull fermion site type but without a doubly occupied state in the Hilbert space.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/boson.jl">Boson sites</a> - General d-dimensional local Hilbert space. Shares the same operator definitions as the <code>&quot;Qudit&quot;</code> site type.</li><li><a href="https://github.com/ITensor/ITensors.jl/blob/main/src/physics/site_types/qudit.jl">Qudit sites</a> - General d-dimensional local Hilbert space. Generalization of the <code>&quot;Qubit&quot;</code> site type, shares the same operator definitions as the <span>$Boson$</span> site type.</li></ul><h2 id="Make-a-Custom-Local-Hilbert-Space-with-QNs"><a class="docs-heading-anchor" href="#Make-a-Custom-Local-Hilbert-Space-with-QNs">Make a Custom Local Hilbert Space with QNs</a><a id="Make-a-Custom-Local-Hilbert-Space-with-QNs-1"></a><a class="docs-heading-anchor-permalink" href="#Make-a-Custom-Local-Hilbert-Space-with-QNs" title="Permalink"></a></h2><p>In the previous example above, we discussed the basic, minimal code needed to define a custom local Hilbert space, using the example of a <span>$S=3/2$</span> spin Hilbert space. In those examples, the <code>space</code> function defining the vector space of a <span>$S=3/2$</span> spin only provides the dimension of  the space. But the Hilbert space of a <span>$S=3/2$</span> spin has additional structure, which is that each of its four subspaces (each of dimension 1) can be labeled by  a different <span>$S^z$</span> quantum number.</p><p>In this code formula we will include this extra quantum information in the  definition of the space of a <span>$S=3/2$</span> spin.</p><p><strong>Code Preview</strong></p><p>First let&#39;s see the minimal code needed to add the option for including quantum numbers of our <span>$S=3/2$</span> site type, then we will discuss what each part of the code is doing.</p><pre><code class="language-julia hljs">using ITensors

function ITensors.space(::SiteType&quot;S=3/2&quot;;
                        conserve_qns=false)
  if conserve_qns
    return [QN(&quot;Sz&quot;,3)=&gt;1,QN(&quot;Sz&quot;,1)=&gt;1,
            QN(&quot;Sz&quot;,-1)=&gt;1,QN(&quot;Sz&quot;,-3)=&gt;1]
  end
  return 4
end

ITensors.op(::OpName&quot;Sz&quot;,::SiteType&quot;S=3/2&quot;) =
  [+3/2   0    0    0
     0  +1/2   0    0 
     0    0  -1/2   0
     0    0    0  -3/2]

ITensors.op(::OpName&quot;S+&quot;,::SiteType&quot;S=3/2&quot;) =
  [0  √3  0  0
   0   0  2  0
   0   0  0 √3
   0   0  0  0] 

ITensors.op(::OpName&quot;S-&quot;,::SiteType&quot;S=3/2&quot;) =
  [0   0  0   0
   √3  0  0   0
   0   2  0   0
   0   0  √3  0] 

</code></pre><p>Now let&#39;s look at each part of the code above.</p><p><strong>The space function</strong></p><p>In the previous code example above, we discussed  that the function <code>space</code> tells the ITensor library the basic information about how to construct an Index associated with a special Index tag, in this case the tag <code>&quot;S=3/2&quot;</code>. As in that code formula, if the user does not request that quantum numbers be included (the case <code>conserve_qns=false</code>) then all that the <code>space</code> function returns is the number 4, indicating that a <code>&quot;S=3/2&quot;</code> Index should be of dimension 4.</p><p>But if the <code>conserve_qns</code> keyword argument gets set to <code>true</code>, the <code>space</code> function we defined above returns an array of <code>QN=&gt;Int</code> pairs. (The notation <code>a=&gt;b</code> in Julia constructs a <code>Pair</code> object.) Each pair in the array denotes a subspace. The <code>QN</code> part of each pair says what quantum number the subspace has, and the integer following it indicates the dimension of the subspace.</p><p>After defining the <code>space</code> function this way, you can write code like:</p><pre><code class="language-julia hljs">s = siteind(&quot;S=3/2&quot;; conserve_qns=true)</code></pre><p>to obtain a single <code>&quot;S=3/2&quot;</code> Index which carries quantum number information. The <code>siteind</code> function built into ITensor relies on your custom <code>space</code> function to ask how to construct a <code>&quot;S=3/2&quot;</code> Index but also includes some other Index tags which are conventional for all site indices.</p><p>You can now also call code like:</p><pre><code class="language-julia hljs">N = 100
sites = siteinds(&quot;S=3/2&quot;,N; conserve_qns=true)</code></pre><p>to obtain an array of N <code>&quot;S=3/2&quot;</code> indices which carry quantum numbers.</p><p><strong>The op Function in the Quantum Number Case</strong></p><p>Note that the <code>op</code> function overloads are exactly the same as for the more basic case of defining an <code>&quot;S=3/2&quot;</code> Index type that does not carry quantum numbers. There is no need to upgrade any of the <code>op</code> functions  for the QN-conserving case.  The reason is that all QN, block-sparse information about an ITensor is deduced from the indices of the tensor, and setting elements of such tensors does not require any other special code. </p><p>However, only operators which have a well-defined QN flux–-meaning they always change the quantum number of a state they act on by a well-defined amount–-can be used in practice in the case of QN conservation. Attempting to build an operator, or any ITensor, without a well-defined QN flux out of QN-conserving indices will result in a run time error. An example of an operator that would lead to such an error would be the &quot;Sx&quot; spin operator since it alternately increases <span>$S^z$</span> or decreases <span>$S^z$</span> depending on the state it acts on, thus it does not have a well-defined QN flux. But it is perfectly fine to define an <code>op</code> overload for the &quot;Sx&quot; operator and to make this operator when working with dense,  non-QN-conserving ITensors or when <span>$S^z$</span> is not conserved.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="DMRG.html">« DMRG Examples</a><a class="docs-footer-nextpage" href="../IndexType.html">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 July 2023 03:05">Thursday 20 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
