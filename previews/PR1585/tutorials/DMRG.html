<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DMRG · ITensors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ITensors.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="../getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="../getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="../getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="../getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="../examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="../examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="../examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="../examples/Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../IndexType.html">Index</a></li><li><a class="tocitem" href="../IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="../ITensorType.html">ITensor</a></li><li><a class="tocitem" href="../MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="../QN.html">QN</a></li><li><a class="tocitem" href="../SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="../IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DMRG.html">DMRG</a></li><li><a class="tocitem" href="../Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="../ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="../ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="../Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="../DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="../OpSum.html">OpSum</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="../faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="../faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="../faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="../faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="../faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="../faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="../faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="../UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="../Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="../AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="../Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="../RunningOnGPUs.html">Running on GPUs</a></li><li><a class="tocitem" href="../QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="../CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="../ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="../HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="../DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="DMRG.html">DMRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="DMRG.html">DMRG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/tutorials/DMRG.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="dmrg_tutorial"><a class="docs-heading-anchor" href="#dmrg_tutorial">DMRG Tutorial</a><a id="dmrg_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#dmrg_tutorial" title="Permalink"></a></h1><p>The <a href="https://tensornetwork.org/mps/algorithms/dmrg/">density matrix renormalization group (DMRG)</a> is an algorithm for computing eigenstates of Hamiltonians (or extremal eigenvectors of large, Hermitian matrices). It computes these eigenstates in the <a href="https://tensornetwork.org/mps/">matrix product state (MPS)</a> format.</p><p>Let&#39;s see how to set up and run a DMRG calculation using the ITensor library. We will be interested in finding the ground state of the quantum Hamiltonian <span>$H$</span> given by:</p><p class="math-container">\[H = \sum_{j=1}^{N-1} \mathbf{S}_{j} \cdot \mathbf{S}_{j+1} = \sum_{j=1}^{N-1} S^z_{j} S^z_{j+1} + \frac{1}{2} S^+_{j} S^-_{j+1} + \frac{1}{2} S^-_{j} S^+_{j+1}\]</p><p>This Hamiltonian is known as the one-dimensional Heisenberg model and we will take the spins to be <span>$S=1$</span> spins (spin-one spins). We will consider the case of <span>$N=100$</span> and plan to do five sweeps of DMRG (five passes over the system).</p><p><strong>ITensor DMRG Code</strong></p><p>Let&#39;s look at an entire, working ITensor code that will do this calculation then discuss the main steps. If you need help running the code below, see the getting started page on <a href="../getting_started/RunningCodes.html#Running-ITensor-and-Julia-Codes">Running ITensor and Julia Codes</a>.</p><pre><code class="language-julia hljs">using ITensors, ITensorMPS
let
  N = 100
  sites = siteinds(&quot;S=1&quot;,N)

  os = OpSum()
  for j=1:N-1
    os += &quot;Sz&quot;,j,&quot;Sz&quot;,j+1
    os += 1/2,&quot;S+&quot;,j,&quot;S-&quot;,j+1
    os += 1/2,&quot;S-&quot;,j,&quot;S+&quot;,j+1
  end
  H = MPO(os,sites)

  psi0 = random_mps(sites;linkdims=10)

  nsweeps = 5
  maxdim = [10,20,100,100,200]
  cutoff = [1E-10]

  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)

  return
end</code></pre><p><strong>Steps of The Code</strong></p><p>The first two lines</p><pre><code class="language-julia hljs">using ITensors, ITensorMPS
N = 100
sites = siteinds(&quot;S=1&quot;,N)</code></pre><p>tells the function <code>siteinds</code> to make an array of ITensor <a href="https://itensor.github.io/ITensors.jl/stable/IndexType.html">Index</a> objects which have the properties of <span>$S=1$</span> spins. This means their dimension will be 3 and they will carry the <code>&quot;S=1&quot;</code> tag, which will enable the next part of the code to know how to make appropriate operators for them.</p><p>Try printing out some of these indices to verify their properties:</p><pre><code class="language-julia hljs">@show sites[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(dim=3|id=59|&quot;S=1,Site,n=1&quot;)</code></pre><p>The next part of the code builds the Hamiltonian:</p><pre><code class="language-julia hljs">os = OpSum()
for j=1:N-1
  os += &quot;Sz&quot;,j,&quot;Sz&quot;,j+1
  os += 1/2,&quot;S+&quot;,j,&quot;S-&quot;,j+1
  os += 1/2,&quot;S-&quot;,j,&quot;S+&quot;,j+1
end
H = MPO(os,sites)</code></pre><p>An <code>OpSum</code> is an object which accumulates Hamiltonian terms such as <code>&quot;Sz&quot;,1,&quot;Sz&quot;,2</code> so that they can be summed afterward into a matrix product operator (MPO) tensor network. The line of code <code>H = MPO(os,sites)</code> constructs the Hamiltonian in the MPO format, with physical indices given by the array <code>sites</code>.</p><p>The line</p><pre><code class="language-julia hljs">psi0 = random_mps(sites;linkdims=10)</code></pre><p>constructs an MPS <code>psi0</code> which has the physical indices <code>sites</code> and a bond dimension of 10. It is made by a random quantum circuit that is reshaped into an MPS, so that it will have as generic and unbiased properties as an MPS of that size can have. This choice can help prevent the DMRG calculation from getting stuck in a local minimum.</p><p>The lines</p><pre><code class="language-julia hljs">nsweeps = 5
maxdim = [10,20,100,100,200]
cutoff = [1E-10]</code></pre><p>define the number of DMRG sweeps (five) we will instruct the code to do, as well as the parameters that will control the speed and accuracy of the DMRG algorithm within each sweep. The array <code>maxdim</code> limits the maximum MPS bond dimension allowed during each sweep and <code>cutoff</code> defines the truncation error goal of each sweep (if fewer values are specified than sweeps, the last value is used for all remaining sweeps).</p><p>Finally the call</p><pre><code class="language-julia hljs">energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)</code></pre><p>runs the DMRG algorithm included in ITensor, using <code>psi0</code> as an initial guess for the ground state wavefunction. The optimized MPS <code>psi</code> and its eigenvalue <code>energy</code> are returned.</p><p>After the <code>dmrg</code> function returns, you can take the returned MPS <code>psi</code> and do further calculations with it, such as measuring local operators or computing entanglement entropy.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/NextSteps.html">« Next Steps</a><a class="docs-footer-nextpage" href="QN_DMRG.html">Quantum Number Conserving DMRG »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 November 2024 14:09">Thursday 14 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
