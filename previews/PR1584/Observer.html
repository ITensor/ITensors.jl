<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Observer System for DMRG · ITensors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ITensors.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="examples/Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="ITensorType.html">ITensor</a></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox" checked/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li><li class="is-active"><a class="tocitem" href="Observer.html">Observer System for DMRG</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-Custom-Observer"><span>Defining a Custom Observer</span></a></li><li><a class="tocitem" href="#Calling-DMRG-with-the-Custom-Observer"><span>Calling DMRG with the Custom Observer</span></a></li><li><a class="tocitem" href="#Complete-Sample-Code"><span>Complete Sample Code</span></a></li></ul></li><li><a class="tocitem" href="DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="OpSum.html">OpSum</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="RunningOnGPUs.html">Running on GPUs</a></li><li><a class="tocitem" href="QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li><a class="is-disabled">DMRG</a></li><li class="is-active"><a href="Observer.html">Observer System for DMRG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Observer.html">Observer System for DMRG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/Observer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="observer"><a class="docs-heading-anchor" href="#observer">Observer System for DMRG</a><a id="observer-1"></a><a class="docs-heading-anchor-permalink" href="#observer" title="Permalink"></a></h1><p>An observer is an object which can be passed to the ITensor DMRG algorithm, to allow measurements to be performed throughout the DMRG calculation and to set conditions for early stopping of DMRG.</p><p>The only requirement of an observer is that it is a subtype of <code>AbstractObserver</code>. But to do something interesting, it should also overload at least one the methods <code>measure!</code> or <code>checkdone!</code>.</p><p>A general purpose observer type called <a href="DMRGObserver.html#ITensorMPS.DMRGObserver-Tuple{}"><code>DMRGObserver</code></a> is included with ITensors which already provides some quite useful features. It accepts a list of strings naming local operators to be measured at each step of DMRG, with the results saved for later analysis. It also accepts an optional energy precision, and stops a DMRG calculation early if the energy no longer changes to this precision. For more details about the <a href="DMRGObserver.html#ITensorMPS.DMRGObserver-Tuple{}"><code>DMRGObserver</code></a> type, see the <a href="DMRGObserver.html#DMRGObserver">DMRGObserver</a> documentation page.</p><h2 id="Defining-a-Custom-Observer"><a class="docs-heading-anchor" href="#Defining-a-Custom-Observer">Defining a Custom Observer</a><a id="Defining-a-Custom-Observer-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Custom-Observer" title="Permalink"></a></h2><p>To define a custom observer, just make a struct with any name and internal fields you would like, and make this struct a subtype of <code>AbstractObserver</code>.</p><p>For example, let&#39;s make a type called <code>DemoObserver</code> as:</p><pre><code class="language-julia hljs">using ITensors, ITensorMPS

mutable struct DemoObserver &lt;: AbstractObserver
   energy_tol::Float64
   last_energy::Float64

   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)
end
</code></pre><p>In this minimal example, our <code>DemoObserver</code> contains a field <code>energy_tol</code> which we can use to set an early-stopping condition for DMRG, and an field <code>last_energy</code> which our observer will use internally to keep track of changes to the energy after each sweep.</p><p>Now to give our <code>DemoObserver</code> type a useful behavior we need to define overloads of the methods <code>measure!</code> and <code>checkdone!</code>.</p><h3 id="Overloading-the-checkdone!-method"><a class="docs-heading-anchor" href="#Overloading-the-checkdone!-method">Overloading the <code>checkdone!</code> method</a><a id="Overloading-the-checkdone!-method-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-the-checkdone!-method" title="Permalink"></a></h3><p>Let&#39;s start with the <code>checkdone!</code> method. After each sweep of DMRG, the <code>checkdone!</code> method is passed the observer object, as well as a set of keyword arguments which currently include:</p><ul><li>energy: the current energy</li><li>psi: the current wavefunction MPS</li><li>sweep: the number of the sweep that just finished</li><li>outputlevel: an integer stating the desired level of output</li></ul><p>If the <code>checkdone!</code> function returns <code>true</code>, then the DMRG routine stops (recall that <code>checkdone!</code> is called only at the end of a sweep).</p><p>In our example, we will just compare the <code>energy</code> keyword argument to the <code>last_energy</code> variable held inside the <code>DemoObserver</code>:</p><pre><code class="language-julia hljs">function ITensors.checkdone!(o::DemoObserver;kwargs...)
  sw = kwargs[:sweep]
  energy = kwargs[:energy]
  if abs(energy-o.last_energy)/abs(energy) &lt; o.energy_tol
    println(&quot;Stopping DMRG after sweep $sw&quot;)
    return true
  end
  # Otherwise, update last_energy and keep going
  o.last_energy = energy
  return false
end</code></pre><p>(Recall that in order to properly overload the default behavior, the <code>checkdone!</code> method has to be imported from the ITensors module or preceded with <code>ITensors.</code>)</p><h3 id="Overloading-the-measure!-method"><a class="docs-heading-anchor" href="#Overloading-the-measure!-method">Overloading the <code>measure!</code> method</a><a id="Overloading-the-measure!-method-1"></a><a class="docs-heading-anchor-permalink" href="#Overloading-the-measure!-method" title="Permalink"></a></h3><p>The other method that an observer can overload is <code>measure!</code>. This method is called at every step of DMRG, so at every site and for every sweep. The <code>measure!</code> method is passed the current observer object and a set of keyword arguments which include:</p><ul><li>energy: the energy after the current step of DMRG</li><li>psi: the current wavefunction MPS</li><li>bond: the bond <code>b</code> that was just optimized, corresponding to sites <code>(b,b+1)</code> in the two-site DMRG algorithm</li><li>sweep: the current sweep number</li><li>sweep_is_done: true if at the end of the current sweep, otherwise false</li><li>half_sweep: the half-sweep number, equal to 1 for a left-to-right, first half sweep, or 2 for the second, right-to-left half sweep</li><li>spec: the Spectrum object returned from factorizing the local superblock wavefunction tensor in two-site DMRG</li><li>outputlevel: an integer specifying the amount of output to show</li><li>projected_operator: projection of the linear operator into the current MPS basis</li></ul><p>For our minimal <code>DemoObserver</code> example here, we will just make a <code>measure!</code> function that prints out some of the information above, but in a more realistic setting one could use the MPS <code>psi</code> to perform essentially arbitrary measurements.</p><pre><code class="language-julia hljs">function ITensors.measure!(o::DemoObserver; kwargs...)
  energy = kwargs[:energy]
  sweep = kwargs[:sweep]
  bond = kwargs[:bond]
  outputlevel = kwargs[:outputlevel]

  if outputlevel &gt; 0
    println(&quot;Sweep $sweep at bond $bond, the energy is $energy&quot;)
  end
end</code></pre><h2 id="Calling-DMRG-with-the-Custom-Observer"><a class="docs-heading-anchor" href="#Calling-DMRG-with-the-Custom-Observer">Calling DMRG with the Custom Observer</a><a id="Calling-DMRG-with-the-Custom-Observer-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-DMRG-with-the-Custom-Observer" title="Permalink"></a></h2><p>After defining an observer type and overloading at least one of the methods <code>checkdone!</code> or <code>measure!</code> for it, one can construct an object of this type and pass it to the ITensor <a href="DMRG.html#ITensorMPS.dmrg"><code>dmrg</code></a> function using the <code>observer</code> keyword argument.</p><p>Continuing with our <code>DemoObserver</code> example above:</p><pre><code class="language-julia hljs">obs = DemoObserver(1E-4) # use an energy tolerance of 1E-4
energy, psi = dmrg(H,psi0,sweeps; observer=obs, outputlevel=1)</code></pre><h2 id="Complete-Sample-Code"><a class="docs-heading-anchor" href="#Complete-Sample-Code">Complete Sample Code</a><a id="Complete-Sample-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Sample-Code" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ITensors, ITensorMPS

mutable struct DemoObserver &lt;: AbstractObserver
   energy_tol::Float64
   last_energy::Float64

   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)
end

function ITensors.checkdone!(o::DemoObserver;kwargs...)
  sw = kwargs[:sweep]
  energy = kwargs[:energy]
  if abs(energy-o.last_energy)/abs(energy) &lt; o.energy_tol
    println(&quot;Stopping DMRG after sweep $sw&quot;)
    return true
  end
  # Otherwise, update last_energy and keep going
  o.last_energy = energy
  return false
end

function ITensors.measure!(o::DemoObserver; kwargs...)
  energy = kwargs[:energy]
  sweep = kwargs[:sweep]
  bond = kwargs[:bond]
  outputlevel = kwargs[:outputlevel]

  if outputlevel &gt; 0
    println(&quot;Sweep $sweep at bond $bond, the energy is $energy&quot;)
  end
end

let
  N = 10
  etol = 1E-4

  s = siteinds(&quot;S=1/2&quot;,N)

  a = OpSum()
  for n=1:N-1
    a += &quot;Sz&quot;,n,&quot;Sz&quot;,n+1
    a += 0.5,&quot;S+&quot;,n,&quot;S-&quot;,n+1
    a += 0.5,&quot;S-&quot;,n,&quot;S+&quot;,n+1
  end
  H = MPO(a,s)
  psi0 = random_mps(s;linkdims=4)

  nsweeps = 5
  cutoff = 1E-8
  maxdim = [10,20,100]

  obs = DemoObserver(etol)

  println(&quot;Starting DMRG&quot;)
  energy, psi = dmrg(H,psi0; nsweeps, cutoff, maxdim, observer=obs, outputlevel=1)

  return
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ProjMPOSum.html">« ProjMPOSum</a><a class="docs-footer-nextpage" href="DMRGObserver.html">DMRGObserver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 November 2024 13:57">Thursday 14 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
