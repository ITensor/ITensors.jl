<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MPS and MPO · ITensors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ITensors.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="examples/Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="ITensorType.html">ITensor</a></li><li class="is-active"><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#MPS-Constructors"><span>MPS Constructors</span></a></li><li><a class="tocitem" href="#MPO-Constructors"><span>MPO Constructors</span></a></li><li><a class="tocitem" href="#Copying-behavior"><span>Copying behavior</span></a></li><li><a class="tocitem" href="#Properties"><span>Properties</span></a></li><li><a class="tocitem" href="#Obtaining-and-finding-indices"><span>Obtaining and finding indices</span></a></li><li><a class="tocitem" href="#Priming-and-tagging"><span>Priming and tagging</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Gate-evolution"><span>Gate evolution</span></a></li><li><a class="tocitem" href="#Algebra-Operations"><span>Algebra Operations</span></a></li></ul></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="OpSum.html">OpSum (AutoMPO)</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="RunningOnGPUs.html">Running on GPUs</a></li><li><a class="tocitem" href="QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="MPSandMPO.html">MPS and MPO</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="MPSandMPO.html">MPS and MPO</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/MPSandMPO.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPS-and-MPO"><a class="docs-heading-anchor" href="#MPS-and-MPO">MPS and MPO</a><a id="MPS-and-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#MPS-and-MPO" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS" href="#ITensors.ITensorMPS.MPS"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPS</code></pre><p>A finite size matrix product state type. Keeps track of the orthogonality center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPO" href="#ITensors.ITensorMPS.MPO"><code>ITensors.ITensorMPS.MPO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPO</code></pre><p>A finite size matrix product operator type. Keeps track of the orthogonality center.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L5-L10">source</a></section></article><h2 id="MPS-Constructors"><a class="docs-heading-anchor" href="#MPS-Constructors">MPS Constructors</a><a id="MPS-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#MPS-Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Int64}" href="#ITensors.ITensorMPS.MPS-Tuple{Int64}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS(N::Int)</code></pre><p>Construct an MPS with N sites with default constructed ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}}" href="#ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS([::Type{ElT} = Float64, ]sites; linkdims=1)</code></pre><p>Construct an MPS filled with Empty ITensors of type <code>ElT</code> from a collection of indices.</p><p>Optionally specify the link dimension with the keyword argument <code>linkdims</code>, which by default is 1.</p><p>In the future we may generalize <code>linkdims</code> to allow specifying each individual link dimension as a vector, and additionally allow specifying quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.randomMPS-Tuple{Vector{&lt;:Index}}" href="#ITensors.ITensorMPS.randomMPS-Tuple{Vector{&lt;:Index}}"><code>ITensors.ITensorMPS.randomMPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomMPS(sites::Vector{&lt;:Index}; linkdims=1)
randomMPS(eltype::Type{&lt;:Number}, sites::Vector{&lt;:Index}; linkdims=1)</code></pre><p>Construct a random MPS with link dimension <code>linkdims</code> which by default has element type <code>Float64</code>.</p><p><code>linkdims</code> can also accept a <code>Vector{Int}</code> with <code>length(linkdims) == length(sites) - 1</code> for constructing an MPS with non-uniform bond dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L259-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.randomMPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}}" href="#ITensors.ITensorMPS.randomMPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}}"><code>ITensors.ITensorMPS.randomMPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomMPS(eltype::Type{&lt;:Number}, sites::Vector{&lt;:Index}; linkdims=1)</code></pre><p>Construct a random MPS with link dimension <code>linkdims</code> of type <code>eltype</code>.</p><p><code>linkdims</code> can also accept a <code>Vector{Int}</code> with <code>length(linkdims) == length(sites) - 1</code> for constructing an MPS with non-uniform bond dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L227-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.randomMPS-Tuple{Vector{&lt;:Index}, Any}" href="#ITensors.ITensorMPS.randomMPS-Tuple{Vector{&lt;:Index}, Any}"><code>ITensors.ITensorMPS.randomMPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomMPS(sites::Vector{&lt;:Index}, state; linkdims=1)</code></pre><p>Construct a real, random MPS with link dimension <code>linkdims</code>, made by randomizing an initial product state specified by <code>state</code>. This version of <code>randomMPS</code> is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial <code>state</code> array provided determines the total QN of the resulting random MPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L318-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Vector{&lt;:Index}, Any}" href="#ITensors.ITensorMPS.MPS-Tuple{Vector{&lt;:Index}, Any}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS(sites::Vector{&lt;:Index},states)</code></pre><p>Construct a product state MPS having site indices <code>sites</code>, and which corresponds to the initial state given by the array <code>states</code>. The <code>states</code> array may consist of either an array of integers or strings, as recognized by the <code>state</code> function defined for the relevant Index tag type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 10
sites = siteinds(&quot;S=1/2&quot;, N)
states = [isodd(n) ? &quot;Up&quot; : &quot;Dn&quot; for n in 1:N]
psi = MPS(sites, states)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L460-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, Any}" href="#ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, Any}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS(::Type{T},
    sites::Vector{&lt;:Index},
    states::Union{Vector{String},
                  Vector{Int},
                  String,
                  Int})</code></pre><p>Construct a product state MPS of element type <code>T</code>, having site indices <code>sites</code>, and which corresponds to the initial state given by the array <code>states</code>. The input <code>states</code> may be an array of strings or an array of ints recognized by the <code>state</code> function defined for the relevant Index tag type. In addition, a single string or int can be input to create a uniform state.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 10
sites = siteinds(&quot;S=1/2&quot;, N)
states = [isodd(n) ? &quot;Up&quot; : &quot;Dn&quot; for n in 1:N]
psi = MPS(ComplexF64, sites, states)
phi = MPS(sites, &quot;Up&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L383-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Vector{&lt;:Pair{&lt;:Index}}}" href="#ITensors.ITensorMPS.MPS-Tuple{Vector{&lt;:Pair{&lt;:Index}}}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS(ivals::Vector{&lt;:Pair{&lt;:Index}})</code></pre><p>Construct a product state MPS with element type <code>Float64</code> and nonzero values determined from the input IndexVals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L375-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Pair{&lt;:Index}}}" href="#ITensors.ITensorMPS.MPS-Tuple{Type{&lt;:Number}, Vector{&lt;:Pair{&lt;:Index}}}"><code>ITensors.ITensorMPS.MPS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPS(::Type{T&lt;:Number}, ivals::Vector{&lt;:Pair{&lt;:Index}})</code></pre><p>Construct a product state MPS with element type <code>T</code> and nonzero values determined from the input IndexVals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L329-L334">source</a></section></article><h2 id="MPO-Constructors"><a class="docs-heading-anchor" href="#MPO-Constructors">MPO Constructors</a><a id="MPO-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#MPO-Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPO-Tuple{Int64}" href="#ITensors.ITensorMPS.MPO-Tuple{Int64}"><code>ITensors.ITensorMPS.MPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPO(N::Int)</code></pre><p>Make an MPO of length <code>N</code> filled with default ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPO-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, Vector{String}}" href="#ITensors.ITensorMPS.MPO-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, Vector{String}}"><code>ITensors.ITensorMPS.MPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String})</code></pre><p>Make an MPO with pairs of sites <code>s[i]</code> and <code>s[i]&#39;</code> and operators <code>ops</code> on each site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.MPO-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, String}" href="#ITensors.ITensorMPS.MPO-Tuple{Type{&lt;:Number}, Vector{&lt;:Index}, String}"><code>ITensors.ITensorMPS.MPO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MPO([::Type{ElT} = Float64, ]sites, op::String)</code></pre><p>Make an MPO with pairs of sites <code>s[i]</code> and <code>s[i]&#39;</code> and operator <code>op</code> on every site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L104-L109">source</a></section></article><h2 id="Copying-behavior"><a class="docs-heading-anchor" href="#Copying-behavior">Copying behavior</a><a id="Copying-behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Copying-behavior" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractMPS}" href="#Base.copy-Tuple{AbstractMPS}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(::MPS)
copy(::MPO)</code></pre><p>Make a shallow copy of an MPS or MPO. By shallow copy, it means that a new MPS/MPO is returned, but the data of the tensors are still shared between the returned MPS/MPO and the original MPS/MPO.</p><p>Therefore, replacing an entire tensor of the returned MPS/MPO will not modify the input MPS/MPO, but modifying the data of the returned MPS/MPO will modify the input MPS/MPO.</p><p>Use <a href="MPSandMPO.html#Base.deepcopy-Tuple{AbstractMPS}"><code>deepcopy</code></a> for an alternative that copies the ITensors as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using ITensors

julia&gt; s = siteinds(&quot;S=1/2&quot;, 3);

julia&gt; M1 = randomMPS(s; linkdims=3);

julia&gt; norm(M1)
0.9999999999999999

julia&gt; M2 = copy(M1);

julia&gt; M2[1] *= 2;

julia&gt; norm(M1)
0.9999999999999999

julia&gt; norm(M2)
1.9999999999999998

julia&gt; M3 = copy(M1);

julia&gt; M3[1] .*= 3; # Modifies the tensor data

julia&gt; norm(M1)
3.0000000000000004

julia&gt; norm(M3)
3.0000000000000004</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L240-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy-Tuple{AbstractMPS}" href="#Base.deepcopy-Tuple{AbstractMPS}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deepcopy(::MPS)
deepcopy(::MPO)</code></pre><p>Make a deep copy of an MPS or MPO. By deep copy, it means that a new MPS/MPO is returned that doesn&#39;t share any data with the input MPS/MPO.</p><p>Therefore, modifying the resulting MPS/MPO will note modify the original MPS/MPO.</p><p>Use <a href="MPSandMPO.html#Base.copy-Tuple{AbstractMPS}"><code>copy</code></a> for an alternative that performs a shallow copy that avoids copying the ITensor data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using ITensors

julia&gt; s = siteinds(&quot;S=1/2&quot;, 3);

julia&gt; M1 = randomMPS(s; linkdims=3);

julia&gt; norm(M1)
1.0

julia&gt; M2 = deepcopy(M1);

julia&gt; M2[1] .*= 2; # Modifies the tensor data

julia&gt; norm(M1)
1.0

julia&gt; norm(M2)
2.0

julia&gt; M3 = copy(M1);

julia&gt; M3[1] .*= 3; # Modifies the tensor data

julia&gt; norm(M1)
3.0

julia&gt; norm(M3)
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L289-L332">source</a></section></article><h2 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{AbstractMPS}" href="#Base.eltype-Tuple{AbstractMPS}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(m::MPS)
eltype(m::MPO)</code></pre><p>The element type of the MPS/MPO. Always returns <code>ITensor</code>.</p><p>For the element type of the ITensors of the MPS/MPO, use <code>promote_itensor_eltype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.flux-Tuple{AbstractMPS}" href="#ITensors.flux-Tuple{AbstractMPS}"><code>ITensors.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux(M::MPS)

flux(M::MPO)

totalqn(M::MPS)

totalqn(M::MPO)</code></pre><p>For an MPS or MPO which conserves quantum numbers, compute the total QN flux. For a tensor network such as an MPS or MPO, the flux is the sum of fluxes of each of the tensors in the network. The name <code>totalqn</code> is an alias for <code>flux</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L2297-L2312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.hasqns-Tuple{AbstractMPS}" href="#ITensors.hasqns-Tuple{AbstractMPS}"><code>ITensors.hasqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasqns(M::MPS)

hasqns(M::MPO)</code></pre><p>Return true if the MPS or MPO has tensors which carry quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L2283-L2290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractMPS}" href="#Base.length-Tuple{AbstractMPS}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(::MPS/MPO)</code></pre><p>The number of sites of an MPS/MPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.maxlinkdim-Tuple{AbstractMPS}" href="#ITensors.ITensorMPS.maxlinkdim-Tuple{AbstractMPS}"><code>ITensors.ITensorMPS.maxlinkdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxlinkdim(M::MPS)
maxlinkdim(M::MPO)</code></pre><p>Get the maximum link dimension of the MPS or MPO.</p><p>The minimum this will return is <code>1</code>, even if there are no link indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L956-L964">source</a></section></article><h2 id="Obtaining-and-finding-indices"><a class="docs-heading-anchor" href="#Obtaining-and-finding-indices">Obtaining and finding indices</a><a id="Obtaining-and-finding-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-and-finding-indices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteinds-Tuple{typeof(commoninds), AbstractMPS, AbstractMPS, Int64}" href="#ITensors.SiteTypes.siteinds-Tuple{typeof(commoninds), AbstractMPS, AbstractMPS, Int64}"><code>ITensors.SiteTypes.siteinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteinds(commoninds, A::MPO, B::MPS, j::Integer; kwargs...)
siteinds(commonind, A::MPO, B::MPO, j::Integer; kwargs...)</code></pre><p>Get the site index (or indices) of  the <code>j</code>th MPO tensor of <code>A</code> that is shared with MPS/MPO <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L496-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteinds-Tuple{typeof(uniqueinds), AbstractMPS, AbstractMPS, Int64}" href="#ITensors.SiteTypes.siteinds-Tuple{typeof(uniqueinds), AbstractMPS, AbstractMPS, Int64}"><code>ITensors.SiteTypes.siteinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteinds(uniqueinds, A::MPO, B::MPS, j::Integer; kwargs...)
siteinds(uniqueind, A::MPO, B::MPS, j::Integer; kwargs...)</code></pre><p>Get the site index (or indices) of MPO <code>A</code> that is unique to <code>A</code> (not shared with MPS/MPO <code>B</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L464-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.findsite" href="#ITensors.ITensorMPS.findsite"><code>ITensors.ITensorMPS.findsite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findsite(M::Union{MPS, MPO}, is)</code></pre><p>Return the first site of the MPS or MPO that has at least one Index in common with the Index or collection of indices <code>is</code>.</p><p>To find all sites with common indices with <code>is</code>, use the <code>findsites</code> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">s = siteinds(&quot;S=1/2&quot;, 5)
ψ = randomMPS(s)
findsite(ψ, s[3]) == 3
findsite(ψ, (s[3], s[4])) == 3

M = MPO(s)
findsite(M, s[4]) == 4
findsite(M, s[4]&#39;) == 4
findsite(M, (s[4]&#39;, s[4])) == 4
findsite(M, (s[4]&#39;, s[3])) == 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L532-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.findsites" href="#ITensors.ITensorMPS.findsites"><code>ITensors.ITensorMPS.findsites</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findsites(M::Union{MPS, MPO}, is)</code></pre><p>Return the sites of the MPS or MPO that have indices in common with the collection of site indices <code>is</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">s = siteinds(&quot;S=1/2&quot;, 5)
ψ = randomMPS(s)
findsites(ψ, s[3]) == [3]
findsites(ψ, (s[4], s[1])) == [1, 4]

M = MPO(s)
findsites(M, s[4]) == [4]
findsites(M, s[4]&#39;) == [4]
findsites(M, (s[4]&#39;, s[4])) == [4]
findsites(M, (s[4]&#39;, s[3])) == [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L565-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.firstsiteinds" href="#ITensors.ITensorMPS.firstsiteinds"><code>ITensors.ITensorMPS.firstsiteinds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">firstsiteinds(M::MPO; kwargs...)</code></pre><p>Get a Vector of the first site Index found on each site of M.</p><p>By default, it finds the first site Index with prime level 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L270-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.linkind-Tuple{AbstractMPS, Int64}" href="#ITensors.ITensorMPS.linkind-Tuple{AbstractMPS, Int64}"><code>ITensors.ITensorMPS.linkind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linkind(M::MPS, j::Integer)
linkind(M::MPO, j::Integer)</code></pre><p>Get the link or bond Index connecting the MPS or MPO tensor on site j to site j+1.</p><p>If there is no link Index, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L341-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteind-Tuple{MPS, Int64}" href="#ITensors.SiteTypes.siteind-Tuple{MPS, Int64}"><code>ITensors.SiteTypes.siteind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteind(M::MPS, j::Int; kwargs...)</code></pre><p>Get the first site Index of the MPS. Return <code>nothing</code> if none is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteind-Tuple{typeof(first), MPS, Int64}" href="#ITensors.SiteTypes.siteind-Tuple{typeof(first), MPS, Int64}"><code>ITensors.SiteTypes.siteind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteind(::typeof(first), M::Union{MPS,MPO}, j::Integer; kwargs...)</code></pre><p>Return the first site Index found on the MPS or MPO (the first Index unique to the <code>j</code>th MPS/MPO tensor).</p><p>You can choose different filters, like prime level and tags, with the <code>kwargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L615-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteinds-Tuple{MPS}" href="#ITensors.SiteTypes.siteinds-Tuple{MPS}"><code>ITensors.SiteTypes.siteinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteinds(M::MPS)
siteinds(::typeof(first), M::MPS)</code></pre><p>Get a vector of the first site Index found on each tensor of the MPS.</p><pre><code class="nohighlight hljs">siteinds(::typeof(only), M::MPS)</code></pre><p>Get a vector of the only site Index found on each tensor of the MPS. Errors if more than one is found.</p><pre><code class="nohighlight hljs">siteinds(::typeof(all), M::MPS)</code></pre><p>Get a vector of the all site Indices found on each tensor of the MPS. Returns a Vector of IndexSets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L501-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteind-Tuple{MPO, Int64}" href="#ITensors.SiteTypes.siteind-Tuple{MPO, Int64}"><code>ITensors.SiteTypes.siteind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteind(M::MPO, j::Int; plev = 0, kwargs...)</code></pre><p>Get the first site Index of the MPO found, by default with prime level 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L236-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteinds-Tuple{MPO}" href="#ITensors.SiteTypes.siteinds-Tuple{MPO}"><code>ITensors.SiteTypes.siteinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteinds(M::MPO; kwargs...)</code></pre><p>Get a Vector of IndexSets of all the site indices of M.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.SiteTypes.siteinds-Tuple{AbstractMPS, Int64}" href="#ITensors.SiteTypes.siteinds-Tuple{AbstractMPS, Int64}"><code>ITensors.SiteTypes.siteinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">siteinds(M::Union{MPS, MPO}}, j::Integer; kwargs...)</code></pre><p>Return the site Indices found of the MPO or MPO at the site <code>j</code> as an IndexSet.</p><p>Optionally filter prime tags and prime levels with keyword arguments like <code>plev</code> and <code>tags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L637-L645">source</a></section></article><h2 id="Priming-and-tagging"><a class="docs-heading-anchor" href="#Priming-and-tagging">Priming and tagging</a><a id="Priming-and-tagging-1"></a><a class="docs-heading-anchor-permalink" href="#Priming-and-tagging" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{AbstractMPS}" href="#ITensors.prime-Tuple{AbstractMPS}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](M::MPS, args...; kwargs...)
prime[!](M::MPO, args...; kwargs...)</code></pre><p>Apply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.prime-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](siteinds, M::MPS, args...; kwargs...)
prime[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply prime to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.prime-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](linkinds, M::MPS, args...; kwargs...)
prime[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply prime to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.prime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
prime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply prime to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.prime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply prime to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swapprime-Tuple{AbstractMPS, Vararg{Any}}" href="#ITensors.swapprime-Tuple{AbstractMPS, Vararg{Any}}"><code>ITensors.swapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swapprime[!](M::MPS, args...; kwargs...)
swapprime[!](M::MPO, args...; kwargs...)</code></pre><p>Apply swapprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{AbstractMPS}" href="#ITensors.setprime-Tuple{AbstractMPS}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](M::MPS, args...; kwargs...)
setprime[!](M::MPO, args...; kwargs...)</code></pre><p>Apply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.setprime-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](siteinds, M::MPS, args...; kwargs...)
setprime[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply setprime to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.setprime-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](linkinds, M::MPS, args...; kwargs...)
setprime[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply setprime to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.setprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
setprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply setprime to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.setprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply setprime to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{AbstractMPS}" href="#ITensors.noprime-Tuple{AbstractMPS}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](M::MPS, args...; kwargs...)
noprime[!](M::MPO, args...; kwargs...)</code></pre><p>Apply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.noprime-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](siteinds, M::MPS, args...; kwargs...)
noprime[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply noprime to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.noprime-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](linkinds, M::MPS, args...; kwargs...)
noprime[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply noprime to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.noprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
noprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply noprime to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.noprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply noprime to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.addtags-Tuple{AbstractMPS}" href="#ITensors.TagSets.addtags-Tuple{AbstractMPS}"><code>ITensors.TagSets.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](M::MPS, args...; kwargs...)
addtags[!](M::MPO, args...; kwargs...)</code></pre><p>Apply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.addtags-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.TagSets.addtags-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.TagSets.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](siteinds, M::MPS, args...; kwargs...)
addtags[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply addtags to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.addtags-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.TagSets.addtags-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.TagSets.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](linkinds, M::MPS, args...; kwargs...)
addtags[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply addtags to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
addtags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply addtags to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply addtags to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.removetags-Tuple{AbstractMPS}" href="#ITensors.TagSets.removetags-Tuple{AbstractMPS}"><code>ITensors.TagSets.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](M::MPS, args...; kwargs...)
removetags[!](M::MPO, args...; kwargs...)</code></pre><p>Apply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.removetags-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.TagSets.removetags-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.TagSets.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](siteinds, M::MPS, args...; kwargs...)
removetags[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply removetags to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.removetags-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.TagSets.removetags-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.TagSets.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](linkinds, M::MPS, args...; kwargs...)
removetags[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply removetags to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
removetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply removetags to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply removetags to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.replacetags-Tuple{AbstractMPS}" href="#ITensors.TagSets.replacetags-Tuple{AbstractMPS}"><code>ITensors.TagSets.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](M::MPS, args...; kwargs...)
replacetags[!](M::MPO, args...; kwargs...)</code></pre><p>Apply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.replacetags-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.TagSets.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](siteinds, M::MPS, args...; kwargs...)
replacetags[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply replacetags to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.replacetags-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.TagSets.replacetags-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.TagSets.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](linkinds, M::MPS, args...; kwargs...)
replacetags[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply replacetags to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
replacetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply replacetags to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.TagSets.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply replacetags to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{AbstractMPS}" href="#ITensors.settags-Tuple{AbstractMPS}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](M::MPS, args...; kwargs...)
settags[!](M::MPO, args...; kwargs...)</code></pre><p>Apply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{typeof(siteinds), AbstractMPS}" href="#ITensors.settags-Tuple{typeof(siteinds), AbstractMPS}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](siteinds, M::MPS, args...; kwargs...)
settags[!](siteinds, M::MPO, args...; kwargs...)</code></pre><p>Apply settags to all site indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L879-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{typeof(linkinds), AbstractMPS}" href="#ITensors.settags-Tuple{typeof(linkinds), AbstractMPS}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](linkinds, M::MPS, args...; kwargs...)
settags[!](linkinds, M::MPO, args...; kwargs...)</code></pre><p>Apply settags to all link indices of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L863-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}" href="#ITensors.settags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)
settags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...)</code></pre><p>Apply settags to the site indices that are shared by <code>M1</code> and <code>M2</code>.</p><p>Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}" href="#ITensors.settags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...)</code></pre><p>Apply settags to the site indices of <code>M1</code> that are not shared with <code>M2</code>. Returns new MPSs/MPOs.</p><p>The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L925-L931">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.expect-Tuple{MPS, Any}" href="#ITensors.ITensorMPS.expect-Tuple{MPS, Any}"><code>ITensors.ITensorMPS.expect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expect(psi::MPS, op::AbstractString...; kwargs...)
expect(psi::MPS, op::Matrix{&lt;:Number}...; kwargs...)
expect(psi::MPS, ops; kwargs...)</code></pre><p>Given an MPS <code>psi</code> and a single operator name, returns a vector of the expected value of the operator on each site of the MPS.</p><p>If multiple operator names are provided, returns a tuple of expectation value vectors.</p><p>If a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>sites = 1:length(psi)</code>: compute expected values only for sites in the given range</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 10

s = siteinds(&quot;S=1/2&quot;, N)
psi = randomMPS(s; linkdims=8)
Z = expect(psi, &quot;Sz&quot;) # compute for all sites
Z = expect(psi, &quot;Sz&quot;; sites=2:4) # compute for sites 2,3,4
Z3 = expect(psi, &quot;Sz&quot;; sites=3)  # compute for site 3 only (output will be a scalar)
XZ = expect(psi, [&quot;Sx&quot;, &quot;Sz&quot;]) # compute Sx and Sz for all sites
Z = expect(psi, [1/2 0; 0 -1/2]) # same as expect(psi,&quot;Sz&quot;)

s = siteinds(&quot;Electron&quot;, N)
psi = randomMPS(s; linkdims=8)
dens = expect(psi, &quot;Ntot&quot;)
updens, dndens = expect(psi, &quot;Nup&quot;, &quot;Ndn&quot;) # pass more than one operator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L944-L982">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}" href="#ITensors.ITensorMPS.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}"><code>ITensors.ITensorMPS.correlation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correlation_matrix(psi::MPS,
                   Op1::AbstractString,
                   Op2::AbstractString;
                   kwargs...)

correlation_matrix(psi::MPS,
                   Op1::Matrix{&lt;:Number},
                   Op2::Matrix{&lt;:Number};
                   kwargs...)</code></pre><p>Given an MPS psi and two strings denoting operators (as recognized by the <code>op</code> function), computes the two-point correlation function matrix C[i,j] = &lt;psi| Op1i Op2j |psi&gt; using efficient MPS techniques. Returns the matrix C.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>sites = 1:length(psi)</code>: compute correlations only  for sites in the given range</li><li><code>ishermitian = false</code> : if <code>false</code>, force independent calculations of the  matrix elements above and below the diagonal, while if <code>true</code> assume they are complex conjugates.</li></ul><p>For a correlation matrix of size NxN and an MPS of typical bond dimension m, the scaling of this algorithm is N^2*m^3.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 30
m = 4

s = siteinds(&quot;S=1/2&quot;, N)
psi = randomMPS(s; linkdims=m)
Czz = correlation_matrix(psi, &quot;Sz&quot;, &quot;Sz&quot;)
Czz = correlation_matrix(psi, [1/2 0; 0 -1/2], [1/2 0; 0 -1/2]) # same as above

s = siteinds(&quot;Electron&quot;, N; conserve_qns=true)
psi = randomMPS(s, n -&gt; isodd(n) ? &quot;Up&quot; : &quot;Dn&quot;; linkdims=m)
Cuu = correlation_matrix(psi, &quot;Cdagup&quot;, &quot;Cup&quot;; sites=2:8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L694-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.dag-Tuple{AbstractMPS}" href="#ITensors.dag-Tuple{AbstractMPS}"><code>ITensors.dag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dag[!](M::MPS, args...; kwargs...)
dag[!](M::MPO, args...; kwargs...)</code></pre><p>Apply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO.</p><p>The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L719-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.dense-Tuple{AbstractMPS}" href="#NDTensors.dense-Tuple{AbstractMPS}"><code>NDTensors.dense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dense(::MPS/MPO)</code></pre><p>Given an MPS (or MPO), return a new MPS (or MPO) having called <code>dense</code> on each ITensor to convert each tensor to use dense storage and remove any QN or other sparse structure information, if it is not dense already.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L450-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.movesite-Tuple{AbstractMPS, Pair{Int64, Int64}}" href="#ITensors.ITensorMPS.movesite-Tuple{AbstractMPS, Pair{Int64, Int64}}"><code>ITensors.ITensorMPS.movesite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">movesite(::Union{MPS, MPO}, n1n2::Pair{Int, Int})</code></pre><p>Create a new MPS/MPO where the site at <code>n1</code> is moved to <code>n2</code>, for a pair <code>n1n2 = n1 =&gt; n2</code>.</p><p>This is done with a series a pairwise swaps, and can introduce a lot of entanglement into your state, so use with caution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1992-L2000">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.orthogonalize!" href="#ITensors.ITensorMPS.orthogonalize!"><code>ITensors.ITensorMPS.orthogonalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orthogonalize!(M::MPS, j::Int; kwargs...)
orthogonalize(M::MPS, j::Int; kwargs...)

orthogonalize!(M::MPO, j::Int; kwargs...)
orthogonalize(M::MPO, j::Int; kwargs...)</code></pre><p>Move the orthogonality center of the MPS to site <code>j</code>. No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors <code>1,2,...,j-1</code> will be left-orthogonal and tensors <code>j+1,j+2,...,N</code> will be right-orthogonal.</p><p>Either modify in-place with <code>orthogonalize!</code> or out-of-place with <code>orthogonalize</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1585-L1601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.replacebond!-Tuple{MPS, Int64, ITensor}" href="#ITensors.ITensorMPS.replacebond!-Tuple{MPS, Int64, ITensor}"><code>ITensors.ITensorMPS.replacebond!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...)</code></pre><p>Factorize the ITensor <code>phi</code> and replace the ITensors <code>b</code> and <code>b+1</code> of MPS <code>M</code> with the factors. Choose the orthogonality with <code>ortho=&quot;left&quot;/&quot;right&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L527-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.sample-Tuple{MPS}" href="#ITensors.ITensorMPS.sample-Tuple{MPS}"><code>ITensors.ITensorMPS.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(m::MPS)</code></pre><p>Given a normalized MPS m with <code>orthocenter(m)==1</code>, returns a <code>Vector{Int}</code> of <code>length(m)</code> corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L634-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.sample!-Tuple{MPS}" href="#ITensors.ITensorMPS.sample!-Tuple{MPS}"><code>ITensors.ITensorMPS.sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample!(m::MPS)</code></pre><p>Given a normalized MPS m, returns a <code>Vector{Int}</code> of <code>length(m)</code> corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mps.jl#L613-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.sample-Tuple{MPO}" href="#ITensors.ITensorMPS.sample-Tuple{MPO}"><code>ITensors.ITensorMPS.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(M::MPO)</code></pre><p>Given a normalized MPO <code>M</code>, returns a <code>Vector{Int}</code> of <code>length(M)</code> corresponding to one sample of the probability distribution defined by the MPO, treating the MPO as a density matrix.</p><p>The MPO <code>M</code> should have an (approximately) positive spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L969-L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.swapbondsites-Tuple{AbstractMPS, Int64}" href="#ITensors.ITensorMPS.swapbondsites-Tuple{AbstractMPS, Int64}"><code>ITensors.ITensorMPS.swapbondsites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swapbondsites(ψ::Union{MPS, MPO}, b::Integer; kwargs...)</code></pre><p>Swap the sites <code>b</code> and <code>b+1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1971-L1975">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.truncate!" href="#NDTensors.truncate!"><code>NDTensors.truncate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate!(M::MPS; kwargs...)
truncate!(M::MPO; kwargs...)</code></pre><p>Perform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments.</p><p>Keyword arguments:</p><ul><li><code>site_range</code>=1:N - only truncate the MPS bonds between these sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1664-L1674">source</a></section></article><h2 id="Gate-evolution"><a class="docs-heading-anchor" href="#Gate-evolution">Gate evolution</a><a id="Gate-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Gate-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.product-Tuple{ITensor, AbstractMPS}" href="#ITensors.product-Tuple{ITensor, AbstractMPS}"><code>ITensors.product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(o::ITensor, ψ::Union{MPS, MPO}, [ns::Vector{Int}]; kwargs...)
product([...])</code></pre><p>Get the product of the operator <code>o</code> with the MPS/MPO <code>ψ</code>, where the operator is applied to the sites <code>ns</code>. If <code>ns</code> are not specified, the sites are determined by the common indices between <code>o</code> and the site indices of <code>ψ</code>.</p><p>If <code>ns</code> are non-contiguous, the sites of the MPS are moved to be contiguous. By default, the sites are moved back to their original locations. You can leave them where they are by setting the keyword argument <code>move_sites_back</code> to false.</p><p><strong>Keywords</strong></p><ul><li><code>cutoff::Real</code>: singular value truncation cutoff.</li><li><code>maxdim::Int</code>: maximum MPS/MPO dimension.</li><li><code>apply_dag::Bool = false</code>: apply the gate and the dagger of the gate (only  relevant for MPO evolution).</li><li><code>move_sites_back::Bool = true</code>: after the ITensors are applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L2081-L2104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.product-Tuple{Vector{ITensor}, AbstractMPS}" href="#ITensors.product-Tuple{Vector{ITensor}, AbstractMPS}"><code>ITensors.product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(As::Vector{&lt;:ITensor}, M::Union{MPS, MPO}; kwargs...)
product([...])</code></pre><p>Apply the ITensors <code>As</code> to the MPS or MPO <code>M</code>, treating them as gates or matrices from pairs of prime or unprimed indices.</p><p><strong>Keywords</strong></p><ul><li><code>cutoff::Real</code>: singular value truncation cutoff.</li><li><code>maxdim::Int</code>: maximum MPS/MPO dimension.</li><li><code>apply_dag::Bool = false</code>: apply the gate and the dagger of the gate (only relevant for MPO evolution).</li><li><code>move_sites_back::Bool = true</code>: after the ITensor is applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations.</li></ul><p><strong>Examples</strong></p><p>Apply one-site gates to an MPS:</p><pre><code class="language-julia hljs">N = 3

ITensors.op(::OpName&quot;σx&quot;, ::SiteType&quot;S=1/2&quot;, s::Index) =
  2*op(&quot;Sx&quot;, s)

ITensors.op(::OpName&quot;σz&quot;, ::SiteType&quot;S=1/2&quot;, s::Index) =
  2*op(&quot;Sz&quot;, s)

# Make the operator list.
os = [(&quot;σx&quot;, n) for n in 1:N]
append!(os, [(&quot;σz&quot;, n) for n in 1:N])

@show os

s = siteinds(&quot;S=1/2&quot;, N)
gates = ops(os, s)

# Starting state |↑↑↑⟩
ψ0 = MPS(s, &quot;↑&quot;)

# Apply the gates.
ψ = apply(gates, ψ0; cutoff = 1e-15)

# Test against exact (full) wavefunction
prodψ = apply(gates, prod(ψ0))
@show prod(ψ) ≈ prodψ

# The result is:
# σz₃ σz₂ σz₁ σx₃ σx₂ σx₁ |↑↑↑⟩ = -|↓↓↓⟩
@show inner(ψ, MPS(s, &quot;↓&quot;)) == -1</code></pre><p>Apply nonlocal two-site gates and one-site gates to an MPS:</p><pre><code class="language-julia hljs"># 2-site gate
function ITensors.op(::OpName&quot;CX&quot;, ::SiteType&quot;S=1/2&quot;, s1::Index, s2::Index)
  mat = [1 0 0 0
         0 1 0 0
         0 0 0 1
         0 0 1 0]
  return itensor(mat, s2&#39;, s1&#39;, s2, s1)
end

os = [(&quot;CX&quot;, 1, 3), (&quot;σz&quot;, 3)]

@show os

# Start with the state |↓↑↑⟩
ψ0 = MPS(s, n -&gt; n == 1 ? &quot;↓&quot; : &quot;↑&quot;)

# The result is:
# σz₃ CX₁₃ |↓↑↑⟩ = -|↓↑↓⟩
ψ = apply(ops(os, s), ψ0; cutoff = 1e-15)
@show inner(ψ, MPS(s, n -&gt; n == 1 || n == 3 ? &quot;↓&quot; : &quot;↑&quot;)) == -1</code></pre><p>Perform TEBD-like time evolution:</p><pre><code class="language-julia hljs"># Define the nearest neighbor term `S⋅S` for the Heisenberg model
function ITensors.op(::OpName&quot;expS⋅S&quot;, ::SiteType&quot;S=1/2&quot;,
                     s1::Index, s2::Index; τ::Number)
  O = 0.5 * op(&quot;S+&quot;, s1) * op(&quot;S-&quot;, s2) +
      0.5 * op(&quot;S-&quot;, s1) * op(&quot;S+&quot;, s2) +
            op(&quot;Sz&quot;, s1) * op(&quot;Sz&quot;, s2)
  return exp(τ * O)
end

τ = -0.1im
os = [(&quot;expS⋅S&quot;, (1, 2), (τ = τ,)),
      (&quot;expS⋅S&quot;, (2, 3), (τ = τ,))]
ψ0 = MPS(s, n -&gt; n == 1 ? &quot;↓&quot; : &quot;↑&quot;)
expτH = ops(os, s)
ψτ = apply(expτH, ψ0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L2140-L2237">source</a></section></article><h2 id="Algebra-Operations"><a class="docs-heading-anchor" href="#Algebra-Operations">Algebra Operations</a><a id="Algebra-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra-Operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS" href="#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>ITensors.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(A::MPS, B::MPS)
inner(A::MPO, B::MPO)</code></pre><p>Compute the inner product <code>⟨A|B⟩</code>. If <code>A</code> and <code>B</code> are MPOs, computes the Frobenius inner product.</p><p>Use <a href="MPSandMPO.html#ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>loginner</code></a> to avoid underflow/overflow for taking overlaps of large MPS or MPO.</p><div class="admonition is-compat"><header class="admonition-header">ITensors 0.3</header><div class="admonition-body"></div></div><p>Before ITensors 0.3, <code>inner</code> had a keyword argument <code>make_inds_match</code> that default to <code>true</code>.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.</p><p>Same as <a href="MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>dot</code></a>.</p><p>See also <a href="MPSandMPO.html#ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>loginner</code></a>, <a href="MPSandMPO.html#ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>logdot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1185-L1198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS" href="#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(A::MPS, B::MPS)
dot(A::MPO, B::MPO)</code></pre><p>Same as <a href="MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>inner</code></a>.</p><p>See also <a href="MPSandMPO.html#ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>loginner</code></a>, <a href="MPSandMPO.html#ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>logdot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1148-L1155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS" href="#ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>ITensors.ITensorMPS.loginner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loginner(A::MPS, B::MPS)
loginner(A::MPO, B::MPO)</code></pre><p>Compute the logarithm of the inner product <code>⟨A|B⟩</code>. If <code>A</code> and <code>B</code> are MPOs, computes the logarithm of the Frobenius inner product.</p><p>This is useful for larger MPS/MPO, where in the limit of large numbers of sites the inner product can diverge or approach zero.</p><div class="admonition is-compat"><header class="admonition-header">ITensors 0.3</header><div class="admonition-body"></div></div><p>Before ITensors 0.3, <code>inner</code> had a keyword argument <code>make_inds_match</code> that default to <code>true</code>.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.</p><p>Same as <a href="MPSandMPO.html#ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>logdot</code></a>.</p><p>See also <a href="MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>inner</code></a>, <a href="MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1201-L1214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS" href="#ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>ITensors.ITensorMPS.logdot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logdot(A::MPS, B::MPS)
logdot(A::MPO, B::MPO)</code></pre><p>Same as <a href="MPSandMPO.html#ITensors.ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>loginner</code></a>.</p><p>See also <a href="MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>inner</code></a>, <a href="MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1160-L1167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.inner-Tuple{MPS, MPO, MPS}" href="#ITensors.inner-Tuple{MPS, MPO, MPS}"><code>ITensors.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(y::MPS, A::MPO, x::MPS)</code></pre><p>Compute <code>⟨y|A|x⟩ = ⟨y|Ax⟩</code> efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than <code>inner(y, apply(A, x))</code>.</p><p>This is helpful for computing the expectation value of an operator <code>A</code>, which would be:</p><pre><code class="language-julia hljs">inner(x&#39;, A, x)</code></pre><p>assuming <code>x</code> is normalized.</p><p>If you want to compute <code>⟨By|Ax⟩</code> you can use <code>inner(B::MPO, y::MPS, A::MPO, x::MPS)</code>.</p><p>This is helpful for computing the variance of an operator <code>A</code>, which would be:</p><pre><code class="language-julia hljs">inner(A, x, A, x) - inner(x&#39;, A, x) ^ 2</code></pre><p>assuming <code>x</code> is normalized.</p><div class="admonition is-compat"><header class="admonition-header">ITensors 0.3</header><div class="admonition-body"></div></div><p>Before ITensors 0.3, <code>inner</code> had a keyword argument <code>make_inds_match</code> that default to <code>true</code>.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.</p><p>Same as <a href="MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L420-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{MPS, MPO, MPS}" href="#LinearAlgebra.dot-Tuple{MPS, MPO, MPS}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(y::MPS, A::MPO, x::MPS)</code></pre><p>Same as <a href="MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.inner-Tuple{MPO, MPS, MPO, MPS}" href="#ITensors.inner-Tuple{MPO, MPS, MPO, MPS}"><code>ITensors.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(B::MPO, y::MPS, A::MPO, x::MPS)</code></pre><p>Compute <code>⟨By|A|x⟩ = ⟨By|Ax⟩</code> efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than <code>inner(apply(B, y), apply(A, x))</code>.</p><p>This is helpful for computing the variance of an operator <code>A</code>, which would be:</p><pre><code class="language-julia hljs">inner(A, x, A, x) - inner(x, A, x) ^ 2</code></pre><div class="admonition is-compat"><header class="admonition-header">ITensors 0.3</header><div class="admonition-body"></div></div><p>Before ITensors 0.3, <code>inner</code> had a keyword argument <code>make_inds_match</code> that default to <code>true</code>.   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly.</p><p>Same as <a href="MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>dot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L507-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{MPO, MPS, MPO, MPS}" href="#LinearAlgebra.dot-Tuple{MPO, MPS, MPO, MPS}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dot(B::MPO, y::MPS, A::MPO, x::MPS)</code></pre><p>Same as <a href="MPSandMPO.html#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractMPS}" href="#LinearAlgebra.norm-Tuple{AbstractMPS}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(A::MPS)
norm(A::MPO)</code></pre><p>Compute the norm of the MPS or MPO.</p><p>If the MPS or MPO has a well defined orthogonality center, this reduces to the norm of the orthogonality center tensor. Otherwise, it computes the norm with the full inner product of the MPS/MPO with itself.</p><p>See also <a href="MPSandMPO.html#ITensors.ITensorMPS.lognorm-Tuple{AbstractMPS}"><code>lognorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1219-L1230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Tuple{AbstractMPS}" href="#LinearAlgebra.normalize-Tuple{AbstractMPS}"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(A::MPS; (lognorm!)=[])
normalize(A::MPO; (lognorm!)=[])</code></pre><p>Return a new MPS or MPO <code>A</code> that is the same as the original MPS or MPO but with <code>norm(A) ≈ 1</code>.</p><p>In practice, this evenly spreads <code>lognorm(A)</code> over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms.</p><p>See also <a href="MPSandMPO.html#LinearAlgebra.normalize!-Tuple{AbstractMPS}"><code>normalize!</code></a>, <a href="MPSandMPO.html#LinearAlgebra.norm-Tuple{AbstractMPS}"><code>norm</code></a>, <a href="MPSandMPO.html#ITensors.ITensorMPS.lognorm-Tuple{AbstractMPS}"><code>lognorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1296-L1306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!-Tuple{AbstractMPS}" href="#LinearAlgebra.normalize!-Tuple{AbstractMPS}"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize!(A::MPS; (lognorm!)=[])
normalize!(A::MPO; (lognorm!)=[])</code></pre><p>Change the MPS or MPO <code>A</code> in-place such that <code>norm(A) ≈ 1</code>. This modifies the data of the tensors within the orthogonality center.</p><p>In practice, this evenly spreads <code>lognorm(A)</code> over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms.</p><p>If the norm of the input MPS or MPO is 0, normalizing is ill-defined. In this case, we just return the original MPS or MPO. You can check for this case as follows:</p><pre><code class="language-julia hljs">s = siteinds(&quot;S=1/2&quot;, 4)
ψ = 0 * randomMPS(s)
lognorm_ψ = []
normalize!(ψ; (lognorm!)=lognorm_ψ)
lognorm_ψ[1] == -Inf # There was an infinite norm</code></pre><p>See also <a href="MPSandMPO.html#LinearAlgebra.normalize-Tuple{AbstractMPS}"><code>normalize</code></a>, <a href="MPSandMPO.html#LinearAlgebra.norm-Tuple{AbstractMPS}"><code>norm</code></a>, <a href="MPSandMPO.html#ITensors.ITensorMPS.lognorm-Tuple{AbstractMPS}"><code>lognorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1311-L1333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.lognorm-Tuple{AbstractMPS}" href="#ITensors.ITensorMPS.lognorm-Tuple{AbstractMPS}"><code>ITensors.ITensorMPS.lognorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lognorm(A::MPS)
lognorm(A::MPO)</code></pre><p>Compute the logarithm of the norm of the MPS or MPO.</p><p>This is useful for larger MPS/MPO that are not gauged, where in the limit of large numbers of sites the norm can diverge or approach zero.</p><p>See also <a href="MPSandMPO.html#LinearAlgebra.norm-Tuple{AbstractMPS}"><code>norm</code></a>, <a href="MPSandMPO.html#ITensors.ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST&lt;:AbstractMPS"><code>logdot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1245-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Vararg{AbstractMPS}}" href="#Base.:+-Tuple{Vararg{AbstractMPS}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(A::MPS/MPO...; kwargs...)
add(A::MPS/MPO...; kwargs...)</code></pre><p>Add arbitrary numbers of MPS/MPO with each other, optionally truncating the results.</p><p>A cutoff of 1e-15 is used by default, and in general users should set their own cutoff for their particular application.</p><p><strong>Keywords</strong></p><ul><li><code>cutoff::Real</code>: singular value truncation cutoff</li><li><code>maxdim::Int</code>: maximum MPS/MPO bond dimension</li><li><code>alg = &quot;densitymatrix&quot;</code>: <code>&quot;densitymatrix&quot;</code> or <code>&quot;directsum&quot;</code>. <code>&quot;densitymatrix&quot;</code> adds the MPS/MPO  by adding up and diagoanlizing local density matrices site by site in a single  sweep through the system, truncating the density matrix with <code>cutoff</code> and <code>maxdim</code>.  <code>&quot;directsum&quot;</code> performs a direct sum of each tensors on each site of the input  MPS/MPO being summed. It doesn&#39;t perform any truncation, and therefore ignores  <code>cutoff</code> and <code>maxdim</code>. The bond dimension of the output is the sum of the bond  dimensions of the inputs. You can truncate the resulting MPS/MPO with the <code>truncate!</code> function.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">N = 10

s = siteinds(&quot;S=1/2&quot;, N; conserve_qns = true)

state = n -&gt; isodd(n) ? &quot;↑&quot; : &quot;↓&quot;
ψ₁ = randomMPS(s, state, 2)
ψ₂ = randomMPS(s, state, 2)
ψ₃ = randomMPS(s, state, 2)

ψ = +(ψ₁, ψ₂; cutoff = 1e-8)

# Can use:
#
# ψ = ψ₁ + ψ₂
#
# but generally you want to set a custom `cutoff` and `maxdim`.

println()
@show inner(ψ, ψ)
@show inner(ψ₁, ψ₂) + inner(ψ₁, ψ₂) + inner(ψ₂, ψ₁) + inner(ψ₂, ψ₂)

# Computes ψ₁ + 2ψ₂
ψ = ψ₁ + 2ψ₂

println()
@show inner(ψ, ψ)
@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + 2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂)

# Computes ψ₁ + 2ψ₂ + ψ₃
ψ = ψ₁ + 2ψ₂ + ψ₃

println()
@show inner(ψ, ψ)
@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + inner(ψ₁, ψ₃) +
      2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂) + 2 * inner(ψ₂, ψ₃) +
      inner(ψ₃, ψ₁) + 2 * inner(ψ₃, ψ₂) + inner(ψ₃, ψ₃)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/abstractmps.jl#L1492-L1553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.contract-Tuple{MPO, MPS}" href="#NDTensors.contract-Tuple{MPO, MPS}"><code>NDTensors.contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract(ψ::MPS, A::MPO; kwargs...) -&gt; MPS
*(::MPS, ::MPO; kwargs...) -&gt; MPS

contract(A::MPO, ψ::MPS; kwargs...) -&gt; MPS
*(::MPO, ::MPS; kwargs...) -&gt; MPS</code></pre><p>Contract the <code>MPO</code> <code>A</code> with the <code>MPS</code> <code>ψ</code>, returning an <code>MPS</code> with the unique site indices of the <code>MPO</code>.</p><p>For example, for an MPO with site indices with prime levels of 1 and 0, such as <code>-s&#39;-A-s-</code>, and an MPS with site indices with prime levels of 0, such as <code>-s-x</code>, the result is an MPS <code>y</code> with site indices with prime levels of 1, <code>-s&#39;-y = -s&#39;-A-s-x</code>.</p><p>Since it is common to contract an MPO with prime levels of 1 and 0 with an MPS with prime level of 0 and want a resulting MPS with prime levels of 0, we provide a convenience function <code>apply</code>:</p><pre><code class="language-julia hljs">apply(A, x; kwargs...) = replaceprime(contract(A, x; kwargs...), 2 =&gt; 1)`.</code></pre><p>Choose the method with the <code>method</code> keyword, for example <code>&quot;densitymatrix&quot;</code> and <code>&quot;naive&quot;</code>.</p><p><strong>Keywords</strong></p><ul><li><code>cutoff::Float64=1e-13</code>: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to  change, in general you should set a <code>cutoff</code> value.</li><li><code>maxdim::Int=maxlinkdim(A) * maxlinkdim(ψ))</code>: the maximal bond dimension of the results MPS.</li><li><code>mindim::Int=1</code>: the minimal bond dimension of the resulting MPS.</li><li><code>normalize::Bool=false</code>: whether or not to normalize the resulting MPS.</li><li><code>method::String=&quot;densitymatrix&quot;</code>: the algorithm to use for the contraction.  Currently the options are &quot;densitymatrix&quot;, where the network formed by the  MPO and MPS is squared and contracted down to a density matrix which is  diagonalized iteratively at each site, and &quot;naive&quot;, where the MPO and MPS  tensor are contracted exactly at each site and then a truncation of the  resulting MPS is performed.</li></ul><p>See also <a href="MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}"><code>apply</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L669-L709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.apply-Tuple{MPO, MPS}" href="#ITensors.apply-Tuple{MPO, MPS}"><code>ITensors.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(A::MPO, x::MPS; kwargs...)</code></pre><p>Contract the <code>MPO</code> <code>A</code> with the <code>MPS</code> <code>x</code> and then map the prime level of the resulting MPS back to 0.</p><p>Equivalent to <code>replaceprime(contract(A, x; kwargs...), 2 =&gt; 1)</code>.</p><p>See also <a href="ContractionSequenceOptimization.html#NDTensors.contract"><code>contract</code></a> for details about the arguments available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L588-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.contract-Tuple{MPO, MPO}" href="#NDTensors.contract-Tuple{MPO, MPO}"><code>NDTensors.contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract(A::MPO, B::MPO; kwargs...) -&gt; MPO
*(::MPO, ::MPO; kwargs...) -&gt; MPO</code></pre><p>Contract the <code>MPO</code> <code>A</code> with the <code>MPO</code> <code>B</code>, returning an <code>MPO</code> with the site indices that are not shared between <code>A</code> and <code>B</code>.</p><p>If you are contracting two MPOs with the same sets of indices, likely you want to call something like:</p><pre><code class="language-julia hljs">C = contract(A&#39;, B; cutoff=1e-12)
C = replaceprime(C, 2 =&gt; 1)</code></pre><p>That is because if MPO <code>A</code> has the index structure <code>-s&#39;-A-s-</code> and MPO <code>B</code> has the Index structure <code>-s&#39;-B-s-</code>, if we only want to contract over on set of the indices, we would do <code>(-s&#39;-A-s-)&#39;-s&#39;-B-s- = -s&#39;&#39;-A-s&#39;-s&#39;-B-s- = -s&#39;&#39;-C-s-</code>, and then map the prime levels back to pairs of primed and unprimed indices with: <code>replaceprime(-s&#39;&#39;-C-s-, 2 =&gt; 1) = -s&#39;-C-s-</code>.</p><p>Since this is a common use case, you can use the convenience function:</p><pre><code class="language-julia hljs">C = apply(A, B; cutoff=1e-12)</code></pre><p>which is the same as the code above.</p><p>If you are contracting MPOs that have diverging norms, such as MPOs representing sums of local operators, the truncation can become numerically unstable (see https://arxiv.org/abs/1909.06341 for a more numerically stable alternative). For now, you can use the following options to contract MPOs like that:</p><pre><code class="language-julia hljs">C = contract(A, B; alg=&quot;naive&quot;, truncate=false)
# Bring the indices back to pairs of primed and unprimed
C = apply(A, B; alg=&quot;naive&quot;, truncate=false)</code></pre><p><strong>Keywords</strong></p><ul><li><code>cutoff::Float64=1e-14</code>: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to change,  in general you should set a <code>cutoff</code> value.</li><li><code>maxdim::Int=maxlinkdim(A) * maxlinkdim(B))</code>: the maximal bond dimension of the results MPS.</li><li><code>mindim::Int=1</code>: the minimal bond dimension of the resulting MPS.</li><li><code>alg=&quot;zipup&quot;</code>: Either <code>&quot;zipup&quot;</code> or <code>&quot;naive&quot;</code>. <code>&quot;zipup&quot;</code> contracts pairs of  site tensors and truncates with SVDs in a sweep across the sites, while <code>&quot;naive&quot;</code>  first contracts pairs of tensor exactly and then truncates at the end if <code>truncate=true</code>.</li><li><code>truncate=true</code>: Enable or disable truncation. If <code>truncate=false</code>, ignore  other truncation parameters like <code>cutoff</code> and <code>maxdim</code>. This is most relevant  for the <code>&quot;naive&quot;</code> version, if you just want to contract the tensors pairwise  exactly. This can be useful if you are contracting MPOs that have diverging  norms, such as MPOs originating from sums of local operators.</li></ul><p>See also <a href="MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}"><code>apply</code></a> for details about the arguments available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L955-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.apply-Tuple{MPO, MPO}" href="#ITensors.apply-Tuple{MPO, MPO}"><code>ITensors.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(A::MPO, B::MPO; kwargs...)</code></pre><p>Contract the <code>MPO</code> <code>A&#39;</code> with the <code>MPO</code> <code>B</code> and then map the prime level of the resulting MPO back to having pairs of indices with prime levels of 1 and 0.</p><p>Equivalent to <code>replaceprime(contract(A&#39;, B; kwargs...), 2 =&gt; 1)</code>.</p><p>See also <a href="ContractionSequenceOptimization.html#NDTensors.contract"><code>contract</code></a> for details about the arguments available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L876-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.error_contract-Tuple{MPS, MPO, MPS}" href="#ITensors.ITensorMPS.error_contract-Tuple{MPS, MPO, MPS}"><code>ITensors.ITensorMPS.error_contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">error_contract(y::MPS, A::MPO, x::MPS;
               make_inds_match::Bool = true)
error_contract(y::MPS, x::MPS, x::MPO;
               make_inds_match::Bool = true)</code></pre><p>Compute the distance between A|x&gt; and an approximation MPS y: <code>| |y&gt; - A|x&gt; |/| A|x&gt; | = √(1 + (&lt;y|y&gt; - 2*real(&lt;y|A|x&gt;))/&lt;Ax|A|x&gt;)</code>.</p><p>If <code>make_inds_match = true</code>, the function attempts match the site indices of <code>y</code> with the site indices of <code>A</code> that are not common with <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L560-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.outer-Tuple{MPS, MPS}" href="#NDTensors.outer-Tuple{MPS, MPS}"><code>NDTensors.outer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outer(x::MPS, y::MPS; &lt;keyword argument&gt;) -&gt; MPO</code></pre><p>Compute the outer product of <code>MPS</code> <code>x</code> and <code>MPS</code> <code>y</code>, returning an <code>MPO</code> approximation. Note that <code>y</code> will be conjugated.</p><p>In Dirac notation, this is the operation <code>|x⟩⟨y|</code>.</p><p>If you want an outer product of an MPS with itself, you should call <code>outer(x&#39;, x; kwargs...)</code> so that the resulting MPO has site indices with indices coming in pairs of prime levels of 1 and 0. If not, the site indices won&#39;t be unique which would not be an outer product.</p><p>For example:</p><pre><code class="language-julia hljs">s = siteinds(&quot;S=1/2&quot;, 5)
x = randomMPS(s)
y = randomMPS(s)
outer(x, y) # Incorrect! Site indices must be unique.
outer(x&#39;, y) # Results in an MPO with pairs of primed and unprimed indices.</code></pre><p>This allows for more general outer products, such as more general MPO outputs which don&#39;t have pairs of primed and unprimed indices, or outer products where the input MPS are vectorizations of MPOs.</p><p>For example:</p><pre><code class="language-julia hljs">s = siteinds(&quot;S=1/2&quot;, 5)
X = MPO(s, &quot;Id&quot;)
Y = MPO(s, &quot;Id&quot;)
x = convert(MPS, X)
y = convert(MPS, Y)
outer(x, y) # Incorrect! Site indices must be unique.
outer(x&#39;, y) # Incorrect! Site indices must be unique.
outer(addtags(x, &quot;Out&quot;), addtags(y, &quot;In&quot;)) # This performs a proper outer product.</code></pre><p>The keyword arguments determine the truncation, and accept the same arguments as <code>contract(::MPO, ::MPO; kwargs...)</code>.</p><p>See also <a href="MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}"><code>apply</code></a>, <a href="ContractionSequenceOptimization.html#NDTensors.contract"><code>contract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L155-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensorMPS.projector-Tuple{MPS}" href="#ITensors.ITensorMPS.projector-Tuple{MPS}"><code>ITensors.ITensorMPS.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projector(x::MPS; &lt;keyword argument&gt;) -&gt; MPO</code></pre><p>Computes the projector onto the state <code>x</code>. In Dirac notation, this is the operation <code>|x⟩⟨x|/|⟨x|x⟩|²</code>.</p><p>Use keyword arguments to control the level of truncation, which are the same as those accepted by <code>contract(::MPO, ::MPO; kw...)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>normalize::Bool=true</code>: whether or not to normalize the input MPS before  forming the projector. If <code>normalize==false</code> and the input MPS is not  already normalized, this function will not output a proper project, and  simply outputs <code>outer(x, x) = |x⟩⟨x|</code>, i.e. the projector scaled by <code>norm(x)^2</code>.</li><li>truncation keyword arguments accepted by <code>contract(::MPO, ::MPO; kw...)</code>.</li></ul><p>See also <a href="MPSandMPO.html#NDTensors.outer-Tuple{MPS, MPS}"><code>outer</code></a>, <a href="ContractionSequenceOptimization.html#NDTensors.contract"><code>contract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/ac4ebeda625e80629b4c8d1b7b4be9ff1ac011bb/src/lib/ITensorMPS/src/mpo.jl#L209-L226">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ITensorType.html">« ITensor</a><a class="docs-footer-nextpage" href="QN.html">QN »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 3 May 2024 02:33">Friday 3 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
