<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ITensor Examples · ITensors.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">ITensors.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="../getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="../getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="../getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="../getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="../tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="../tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li class="is-active"><a class="tocitem" href="ITensor.html">ITensor Examples</a><ul class="internal"><li><a class="tocitem" href="#Print-Indices-of-an-ITensor"><span>Print Indices of an ITensor</span></a></li><li><a class="tocitem" href="#Getting-and-Setting-Elements-of-an-ITensor"><span>Getting and Setting Elements of an ITensor</span></a></li><li><a class="tocitem" href="#Making-ITensors-from-Arrays"><span>Making ITensors from Arrays</span></a></li><li><a class="tocitem" href="#Making-Arrays-from-ITensors"><span>Making Arrays from ITensors</span></a></li><li><a class="tocitem" href="#Arithmetic-With-ITensors"><span>Arithmetic With ITensors</span></a></li><li><a class="tocitem" href="#Elementwise-Operations-on-ITensors"><span>Elementwise Operations on ITensors</span></a></li><li><a class="tocitem" href="#Making-an-ITensor-with-a-Single-Non-Zero-Element"><span>Making an ITensor with a Single Non-Zero Element</span></a></li><li><a class="tocitem" href="#Tracing-an-ITensor"><span>Tracing an ITensor</span></a></li><li><a class="tocitem" href="#Factoring-ITensors-(SVD,-QR,-etc.)"><span>Factoring ITensors (SVD, QR, etc.)</span></a></li><li><a class="tocitem" href="#Combining-Multiple-Indices-into-One-Index"><span>Combining Multiple Indices into One Index</span></a></li><li><a class="tocitem" href="#Write-and-Read-an-ITensor-to-Disk-with-HDF5"><span>Write and Read an ITensor to Disk with HDF5</span></a></li></ul></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../IndexType.html">Index</a></li><li><a class="tocitem" href="../IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="../ITensorType.html">ITensor</a></li><li><a class="tocitem" href="../MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="../QN.html">QN</a></li><li><a class="tocitem" href="../SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="../IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DMRG.html">DMRG</a></li><li><a class="tocitem" href="../Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="../ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="../ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="../Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="../DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="../OpSum.html">OpSum</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="../faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="../faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="../faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="../faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="../faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="../faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="../faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="../UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="../Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="../AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="../Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="../RunningOnGPUs.html">Running on GPUs</a></li><li><a class="tocitem" href="../QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="../CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="../ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="../HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="../DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Code Examples</a></li><li class="is-active"><a href="ITensor.html">ITensor Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ITensor.html">ITensor Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/examples/ITensor.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="itensor_examples"><a class="docs-heading-anchor" href="#itensor_examples">ITensor Code Examples</a><a id="itensor_examples-1"></a><a class="docs-heading-anchor-permalink" href="#itensor_examples" title="Permalink"></a></h1><h2 id="Print-Indices-of-an-ITensor"><a class="docs-heading-anchor" href="#Print-Indices-of-an-ITensor">Print Indices of an ITensor</a><a id="Print-Indices-of-an-ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Print-Indices-of-an-ITensor" title="Permalink"></a></h2><p>Sometimes the printout of an ITensor can be rather large, whereas you might only want to see its indices. For these cases, just wrap the ITensor in the function <code>inds</code> like this:</p><pre><code class="language-julia hljs">@show inds(T)</code></pre><p>or this</p><pre><code class="language-julia hljs">println(&quot;T inds = &quot;,inds(T))</code></pre><h2 id="Getting-and-Setting-Elements-of-an-ITensor"><a class="docs-heading-anchor" href="#Getting-and-Setting-Elements-of-an-ITensor">Getting and Setting Elements of an ITensor</a><a id="Getting-and-Setting-Elements-of-an-ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-Setting-Elements-of-an-ITensor" title="Permalink"></a></h2><p>Say we have an ITensor constructed as:</p><pre><code class="language-julia hljs">i = Index(3,&quot;index_i&quot;)
j = Index(2,&quot;index_j&quot;)
k = Index(4,&quot;index_k&quot;)

T = ITensor(i,j,k)</code></pre><p>An ITensor constructed this way starts with all of its elements equal to zero. (Technically it allocates no storage at all but this is an implementation detail.)</p><p><strong>Setting Elements</strong></p><p>To set an element of this ITensor, such as the element where <code>(i,j,k) = (2,1,3)</code>, you can do the following:</p><pre><code class="language-julia hljs">T[i=&gt;2,j=&gt;1,k=&gt;3] = -3.2</code></pre><p>In the Julia language, the notation <code>a=&gt;b</code> is a built-in notation for making a <code>Pair(a,b)</code> object.</p><p>Because the Index objects are passed to <code>T</code> along with their values, passing them in a different order has exactly the same effect:</p><pre><code class="language-julia hljs"># Both of these lines of code do the same thing:
T[j=&gt;1,i=&gt;2,k=&gt;3] = -3.2
T[j=&gt;1,k=&gt;3,i=&gt;2] = -3.2</code></pre><p><strong>Getting Elements</strong></p><p>You can retrieve individual elements of an ITensor by accessing them through the same notation used to set elements:</p><pre><code class="language-julia hljs">el = T[j=&gt;1,i=&gt;2,k=&gt;3]
println(&quot;The (i,j,k) = (2,1,3) element of T is &quot;,el)</code></pre><h2 id="Making-ITensors-from-Arrays"><a class="docs-heading-anchor" href="#Making-ITensors-from-Arrays">Making ITensors from Arrays</a><a id="Making-ITensors-from-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Making-ITensors-from-Arrays" title="Permalink"></a></h2><p>To initialize all of the elements of an ITensor at once, you can pass a Julia array into the ITensor constructor.</p><p>For example, if we want to construct an ITensor <code>A</code> with indices <code>i,j</code> we can initialize it from a matrix as follows:</p><pre><code class="language-julia hljs">M = [1.0 2.0;
     3.0 4.0]

i = Index(2,&quot;i&quot;)
j = Index(2,&quot;j&quot;)

A = ITensor(M,i,j)</code></pre><p>More generally we can use an nth-order (n-dimensional) Julia array to initialize an ITensor:</p><pre><code class="language-julia hljs">T = randn(4,7,2)

k = Index(4,&quot;index_k&quot;)
l = Index(7,&quot;index_l&quot;)
m = Index(2,&quot;index_m&quot;)

B = ITensor(T,k,l,m)</code></pre><h2 id="Making-Arrays-from-ITensors"><a class="docs-heading-anchor" href="#Making-Arrays-from-ITensors">Making Arrays from ITensors</a><a id="Making-Arrays-from-ITensors-1"></a><a class="docs-heading-anchor-permalink" href="#Making-Arrays-from-ITensors" title="Permalink"></a></h2><p>Not only can we make an ITensor from a Julia array, but we can also convert an ITensor back into a Julia array.</p><p>Say we have made an ITensor with two indices:</p><pre><code class="language-julia hljs">k = Index(4,&quot;index_k&quot;)
m = Index(2,&quot;index_m&quot;)

T = random_itensor(k,m)
@show T</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">T = ITensor ord=2
Dim 1: (dim=4|id=15|&quot;index_k&quot;)
Dim 2: (dim=2|id=293|&quot;index_m&quot;)
NDTensors.Dense{Float64, Vector{Float64}}
 4×2
 -0.037025446544394686   0.4967800795298839
  1.0385083710609093    -1.1365439665054196
 -0.008459604708858568  -0.7323515828225137
 -1.7197162929029437     0.6578006949261739</code></pre><p>Here we used the <code>random_itensor</code> constructor to fill T with random elements but we could make an ITensor some other way too.</p><p>Now to convert <code>T</code> into a regular Julia array <code>A</code>, use the <a href="../ITensorType.html#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}} where {ElT, N}"><code>Array</code></a> constructor and pass the indices of <code>T</code> in the order that you want:</p><pre><code class="language-julia hljs">A = Array(T,k,m)
@show A</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Float64}:
 -0.0370254   0.49678
  1.03851    -1.13654
 -0.0084596  -0.732352
 -1.71972     0.657801</code></pre><p>The reason you have to pass the indices is that the ordering of ITensor indices is an implementation detail and not part of the user interface. So when leaving the ITensor system and converting to a regular array, you must say what ordering of the indices you want. Making the array as <code>A = Array(T,m,k)</code> would give the transpose of the array in the code above.</p><p>Note that for efficiency reasons, the array returned by the <code>array</code> function will sometimes be a <em>view</em> of the ITensor, such that changing an element of <code>A</code> would also change the corresponding element of <code>T</code>. This is not always the case though: for example if the indices are passed in a different order from how the internal ITensor storage is arranged, or if  <code>T</code> is a block-sparse ITensor, since the (not stored) zero blocks will need to be filled in.</p><h2 id="Arithmetic-With-ITensors"><a class="docs-heading-anchor" href="#Arithmetic-With-ITensors">Arithmetic With ITensors</a><a id="Arithmetic-With-ITensors-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-With-ITensors" title="Permalink"></a></h2><p>ITensors can be added and subtracted and multiplied by scalars just like plain tensors can. But ITensors have the additional feature that you can add and subtract them even if their indices are in a different order from each other, as long as they have the same collection of indices.</p><p>For example, say we have ITensors <code>A</code>, <code>B</code>, and <code>C</code>:</p><pre><code class="language-julia hljs">i = Index(3,&quot;i&quot;)
j = Index(2,&quot;j&quot;)
k = Index(4,&quot;k&quot;)

A = random_itensor(i,j,k)
B = random_itensor(i,j,k)
C = random_itensor(k,i,j)</code></pre><p>Above we have initialized these ITensors to have random elements, just for the sake of this example.</p><p>We can then add or subtract these ITensors</p><pre><code class="language-julia hljs">R1 = A + B
R2 = A - B
R3 = A + B - C</code></pre><p>or do more complicated operations involving real and complex scalars too:</p><pre><code class="language-julia hljs">R4 = 2.0*A - B + C/(1+1im)</code></pre><h2 id="Elementwise-Operations-on-ITensors"><a class="docs-heading-anchor" href="#Elementwise-Operations-on-ITensors">Elementwise Operations on ITensors</a><a id="Elementwise-Operations-on-ITensors-1"></a><a class="docs-heading-anchor-permalink" href="#Elementwise-Operations-on-ITensors" title="Permalink"></a></h2><p>[<em>Note: currently elementwise operations are only defined for dense ITensors, not for block-sparse QN ITensors.</em>]</p><p>ITensors support Julia broadcasting operations, making it quite easy to carry out element-wise operations on them in a very similar way as for regular Julia arrays. As a concrete example, consider the following ITensor initialized with random elements</p><pre><code class="language-julia hljs">i = Index(2,&quot;i&quot;)
j = Index(3,&quot;j&quot;)

A = random_itensor(i,j)</code></pre><p>Here are some examples of basic element-wise operations we can do using Julia&#39;s dotted operator broadcasting syntax.</p><pre><code class="language-julia hljs"># Multiply every element of `A` by 2.0:
A .*= 2.0</code></pre><pre><code class="language-julia hljs"># Add 1.5 to every element of A
A .+= 1.5</code></pre><p>The dotted notation works for functions too:</p><pre><code class="language-julia hljs"># Replace every element in A by its absolute value:
A .= abs.(A)</code></pre><pre><code class="language-julia hljs"># Replace every element in A by the number 1.0
A .= one.(A)</code></pre><p>If have another ITensor <code>B = ITensor(j,i)</code>, which has the same set of indices though possibly in a different order, then we can also do element-wise operations involving both ITensors:</p><pre><code class="language-julia hljs"># Add elements of A and B element-wise
A .= A .+ B
# Add elements of A and B element-wise with coefficients included
A .= (2.0 .* A) .+ (-3.0 .* B)</code></pre><p>Last but not least, it is possible to make custom functions yourself and broadcast them across elements of ITensors:</p><pre><code class="language-julia hljs">myf(x) = 1.0/(1.0+exp(-x))
T .= myf.(T)</code></pre><h2 id="Making-an-ITensor-with-a-Single-Non-Zero-Element"><a class="docs-heading-anchor" href="#Making-an-ITensor-with-a-Single-Non-Zero-Element">Making an ITensor with a Single Non-Zero Element</a><a id="Making-an-ITensor-with-a-Single-Non-Zero-Element-1"></a><a class="docs-heading-anchor-permalink" href="#Making-an-ITensor-with-a-Single-Non-Zero-Element" title="Permalink"></a></h2><p>It is often useful to make ITensors with all elements zero except for a specific element that is equal to 1.0. Use cases can include making product-state quantum wavefunctions or contracting single-element ITensors with other ITensors to set their indices to a fixed value.</p><p>To make such an ITensor, use the <a href="../ITensorType.html#ITensors.onehot"><code>onehot</code></a> function. Borrowing terminology from engineering, a &quot;one hot&quot; vector or tensor has a single element equal to 1.0 and the rest zero. (In previous versions of ITensor this function was called <code>setelt</code>.)</p><p>The ITensor function <a href="../ITensorType.html#ITensors.onehot"><code>onehot</code></a> takes one or more Index-value Pairs such as <code>i=&gt;2</code> and <code>j=&gt;1</code> and returns an ITensor with a 1.0 in the location specified by the Index values:</p><pre><code class="language-julia hljs">i = Index(2)
O1 = onehot(i=&gt;1)
println(O1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ITensor ord=1
Dim 1: (dim=2|id=888)
NDTensors.Dense{Float64, Vector{Float64}}
 2-element
 1.0
 0.0</code></pre><pre><code class="language-julia hljs">O2 = onehot(i=&gt;2)
println(O2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ITensor ord=1
Dim 1: (dim=2|id=31)
NDTensors.Dense{Float64, Vector{Float64}}
 2-element
 0.0
 1.0</code></pre><pre><code class="language-julia hljs">j = Index(3)
T = onehot(i=&gt;2,j=&gt;3)
println(T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ITensor ord=2
Dim 1: (dim=2|id=551)
Dim 2: (dim=3|id=636)
NDTensors.Dense{Float64, Vector{Float64}}
 2×3
 0.0  0.0  0.0
 0.0  0.0  1.0</code></pre><h2 id="Tracing-an-ITensor"><a class="docs-heading-anchor" href="#Tracing-an-ITensor">Tracing an ITensor</a><a id="Tracing-an-ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Tracing-an-ITensor" title="Permalink"></a></h2><p>An important operation involving a single tensor is tracing out certain pairs of indices. Say we have an ITensor <code>A</code> with indices <code>i,j,l</code>:</p><pre><code class="language-julia hljs">i = Index(4,&quot;i&quot;)
j = Index(3,&quot;j&quot;)
l = Index(4,&quot;l&quot;)

A = random_itensor(i,j,l)</code></pre><p>and we want to trace <code>A</code> by summing over the indices <code>i</code> and <code>l</code> locked together, in other words: <span>$\sum_{i} A^{iji}$</span>.</p><p>To do this in ITensor, we can use a <code>delta</code> tensor, which you can think of as an identity operator or more generally a Kronecker delta or &quot;hyper-edge&quot;:</p><p><img src="itensor_trace_figures/delta_itensor.png" alt/></p><p>Viewed as an array, a delta tensor has all diagonal elements equal to 1.0 and zero otherwise.</p><p>Now we can compute the trace by contracting <code>A</code> with the delta tensor:</p><pre><code class="language-julia hljs">trA = A * delta(i,l)</code></pre><p><img src="itensor_trace_figures/trace_A.png" alt/></p><h2 id="Factoring-ITensors-(SVD,-QR,-etc.)"><a class="docs-heading-anchor" href="#Factoring-ITensors-(SVD,-QR,-etc.)">Factoring ITensors (SVD, QR, etc.)</a><a id="Factoring-ITensors-(SVD,-QR,-etc.)-1"></a><a class="docs-heading-anchor-permalink" href="#Factoring-ITensors-(SVD,-QR,-etc.)" title="Permalink"></a></h2><p>The ITensor approach to tensor factorizations emphasizes the structure of the factorization, and does not require knowing the index ordering.</p><p>ITensor offers various tensor factorizations, such as the singular value decomposition (SVD) and the QR factorization. These are extended to the case of tensors by treating some of the indices as the &quot;row&quot; indices and the rest of the indices as the &quot;column&quot; indices, reshaping the tensor into a matrix to carry out the factorization, then restoring the tensor structure at the end. All of these steps are done for you by the ITensor system as we will see below.</p><h4 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h4><p>The singular value decomposition (SVD) is a matrix factorization that is also extremely useful for general tensors.</p><p>As a brief review, the SVD is a factorization of a matrix M into the product</p><p class="math-container">\[M = U S V^\dagger\]</p><p>with U and V having the property <span>$U^\dagger U = 1$</span> and <span>$V^\dagger V = 1$</span>. The matrix S is diagonal and has real, non-negative entries known as the singular values, which are typically ordered from largest to smallest. The SVD is well-defined for any matrix, including rectangular matrices. It also leads to a controlled approximation, where the error due to discarding columns of U and V is small if the corresponding singular values discarded are small.</p><p>To compute the SVD of an ITensor, you only need to specify which indices are (collectively) the &quot;row&quot; indices (thinking of the ITensor as a matrix), with the rest assumed to be the &quot;column&quot; indices.</p><p>Say we have an ITensor with indices i,j, and k</p><pre><code class="language-julia hljs">T = ITensor(i,j,k)</code></pre><p>and we want to treat i and k as the &quot;row&quot; indices for the purpose of the SVD.</p><p>To perform this SVD, we can call the function <code>svd</code> as follows:</p><pre><code class="language-julia hljs">U,S,V = svd(T,(i,k))</code></pre><p>Diagrammatically the SVD operation above looks like:</p><p><img src="itensor_factorization_figures/SVD_Ex1.png" alt/></p><p>The guarantee of the <code>svd</code> function is that the ITensor product <code>U*S*V</code> gives us back an ITensor identical to T:</p><pre><code class="language-julia hljs">@show norm(U*S*V - T) # typical output: norm(U*S*V-T) = 1E-14</code></pre><p><em>Full working example:</em></p><pre><code class="language-julia hljs">i = Index(3,&quot;i&quot;)
j = Index(4,&quot;j&quot;)
k = Index(5,&quot;k&quot;)

T = random_itensor(i,j,k)

U,S,V = svd(T,(i,k))

@show norm(U*S*V-T)</code></pre><p><strong>Truncated SVD</strong></p><p>An important use of the SVD is approximating a higher-rank tensor by a product of lower-rank tensors whose indices range over only a modest set of values.</p><p>To obtain an approximate SVD in ITensor, pass one or more of the following accuracy parameters as named arguments:</p><ul><li><p><code>cutoff</code> –- real number <span>$\epsilon$</span>. Discard the smallest singular values <span>$\lambda\_n$</span> such that the &lt;i&gt;truncation error&lt;/i&gt; is less than <span>$\epsilon$</span>: $ \frac{\sum_{n\in\text{discarded}} \lambda^2_n}{\sum_{n} \lambda^2_n} &lt; \epsilon \:. $ Using a cutoff allows the SVD algorithm to truncate as many states as possible while still ensuring a certain accuracy.</p></li><li><p><code>maxdim</code> –- integer M. If the number of singular values exceeds M, only the largest M will be retained.</p></li><li><p><code>mindim</code> –- integer m. At least m singular values will be retained, even if some fall below the cutoff</p></li></ul><p>Let us revisit the example above, but also provide some of these accuracy parameters</p><pre><code class="language-julia hljs">i = Index(10,&quot;i&quot;)
j = Index(40,&quot;j&quot;)
k = Index(20,&quot;k&quot;)
T = random_itensor(i,j,k)

U,S,V = svd(T,(i,k),cutoff=1E-2)</code></pre><p>Note that we have also made the indices larger so that the truncation performed will be non-trivial. In the code above, we specified that a cutoff of <span>$\epsilon=10^{-2}$</span> be used. We can check that the resulting factorization is now approximate by computing the squared relative error:</p><pre><code class="language-julia hljs">truncerr = (norm(U*S*V - T)/norm(T))^2
@show truncerr
# typical output: truncerr = 8.24E-03</code></pre><p>Note how the computed error is below the cutoff <span>$\epsilon$</span> we requested.</p><p><em>Full working example including truncation:</em></p><pre><code class="language-julia hljs">i = Index(10,&quot;i&quot;);
j = Index(40,&quot;j&quot;);
k = Index(20,&quot;k&quot;);

T = random_itensor(i,j,k)

U,S,V = svd(T,(i,k),cutoff=1E-2)

@show norm(U*S*V-T)
@show (norm(U*S*V - T)/norm(T))^2</code></pre><h4 id="QR-Factorization"><a class="docs-heading-anchor" href="#QR-Factorization">QR Factorization</a><a id="QR-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#QR-Factorization" title="Permalink"></a></h4><p>Computing the QR factorization of an ITensor works in a similar way as for the SVD. In addition to passing the ITensor you want to factorize, you must also pass the indices you want to end up on the tensor <code>Q</code>, in other words to be treated as the &quot;row&quot; indices for the purpose of defining the QR factorization.</p><p>Say we want to compute the QR factorization of an ITensor <code>T</code> with indices <code>i,j,k</code>, putting the indices <code>i</code> and <code>k</code> onto <code>Q</code> and the remaining indices onto <code>R</code>. We can do this as follows:</p><p><img src="itensor_factorization_figures/QR_Ex1.png" alt/></p><pre><code class="language-julia hljs">T = random_itensor(i,j,k)
Q,R = qr(T,(i,k);positive=true)</code></pre><p>Note the use of the optional <code>positive=true</code> keyword argument, which ensures that the diagonal elements of <code>R</code> are non-negative. With this option, the QR factorization is <em>unique</em>, which can be useful in certain cases.</p><h2 id="Combining-Multiple-Indices-into-One-Index"><a class="docs-heading-anchor" href="#Combining-Multiple-Indices-into-One-Index">Combining Multiple Indices into One Index</a><a id="Combining-Multiple-Indices-into-One-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Multiple-Indices-into-One-Index" title="Permalink"></a></h2><p>It can be very useful to combine or merge multiple indices of an ITensor into a single Index. Say we have an ITensor with indices <code>i,j,k</code> and we want to combine Index <code>i</code> and Index <code>k</code> into a new Index. This new Index (call it <code>c</code>) will have a dimension whose size is the dimension of <code>i</code> times the dimension of <code>k</code>.</p><p>To carry out this procedure we can make a special kind of ITensor: a combiner. To make a combiner, call the function <code>combiner</code>, passing the indices you want to combine:</p><pre><code class="language-julia hljs">C = combiner(i,k; tags=&quot;c&quot;)</code></pre><p>Then if we have an ITensor</p><pre><code class="language-julia hljs">T = random_itensor(i,j,k)
@show inds(T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((dim=4|id=874|&quot;i&quot;), (dim=3|id=757|&quot;j&quot;), (dim=2|id=259|&quot;k&quot;))</code></pre><p>we can combine indices <code>i</code> and <code>k</code> by contracting with the combiner:</p><pre><code class="language-julia hljs">CT = C * T</code></pre><p>Printing out the indices of the new ITensor <code>CT</code> we can see that it has only two indices:</p><pre><code class="language-julia hljs">@show inds(CT)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((dim=8|id=945|&quot;c&quot;), (dim=3|id=757|&quot;j&quot;))</code></pre><p>The first is the newly made combined Index, which was made for us by the <code>combiner</code> function and the second is the <code>j</code> Index of <code>T</code> which was not part of the combining process. To access the combined Index you can call the <code>combinedind</code> function on the combiner:</p><pre><code class="language-julia hljs">ci = combinedind(C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(dim=8|id=945|&quot;c&quot;)</code></pre><p>We can visualize all of the steps above as follows: <img src="combiner_itensor.png" alt/></p><p>Combining is not limited to two indices and you can combine any number of indices, in any order, using a combiner.</p><p>To undo the combining process and uncombine the Index <code>c</code> back into <code>i,k</code>, just contract with the conjugate of the combiner ITensor <code>dag(C)</code>.</p><pre><code class="language-julia hljs">UT = dag(C) * CT
@show inds(UT)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">((dim=4|id=874|&quot;i&quot;), (dim=2|id=259|&quot;k&quot;), (dim=3|id=757|&quot;j&quot;))</code></pre><h2 id="Write-and-Read-an-ITensor-to-Disk-with-HDF5"><a class="docs-heading-anchor" href="#Write-and-Read-an-ITensor-to-Disk-with-HDF5">Write and Read an ITensor to Disk with HDF5</a><a id="Write-and-Read-an-ITensor-to-Disk-with-HDF5-1"></a><a class="docs-heading-anchor-permalink" href="#Write-and-Read-an-ITensor-to-Disk-with-HDF5" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Make sure to install the HDF5 package to use this feature. (Run <code>julia&gt; ] add HDF5</code> in the Julia REPL console.)</p></div></div><p>Saving ITensors to disk can be very useful. For example, you might encounter a bug in your own code, and by reading the ITensors involved from disk you can shortcut the process of running a lengthy algorithm over many times to reproduce the bug. Or you can save the output of an expensive calculation, such as a DMRG calculation, and use it as a starting point for multiple follow-up calculations such as computing time-dependent properties.</p><p>ITensors can be written to files using the HDF5 format. HDF5 offers many benefits such as being portable across different machine types, and offers a standard interface across various libraries and languages.</p><p><strong>Writing an ITensor to an HDF5 File</strong></p><p>Let&#39;s say you have an ITensor <code>T</code> which you have made or obtained from a calculation. To write it to an HDF5 file named &quot;myfile.h5&quot; you can use the following pattern:</p><pre><code class="language-julia hljs">using HDF5
f = h5open(&quot;myfile.h5&quot;,&quot;w&quot;)
write(f,&quot;T&quot;,T)
close(f)</code></pre><p>Above, the string &quot;T&quot; can actually be any string you want such as &quot;ITensor T&quot; or &quot;Result Tensor&quot; and doesn&#39;t have to have the same name as the reference <code>T</code>. Closing the file <code>f</code> is optional and you can also write other objects to the same file before closing it.</p><p><strong>Reading an ITensor from an HDF5 File</strong></p><p>Say you have an HDF5 file &quot;myfile.h5&quot; which contains an ITensor stored as a dataset with the name &quot;T&quot;. (Which would be the situation if you wrote it as in the example above.) To read this ITensor back from the HDF5 file, use the following pattern:</p><pre><code class="language-julia hljs">using HDF5
f = h5open(&quot;myfile.h5&quot;,&quot;r&quot;)
T = read(f,&quot;T&quot;,ITensor)
close(f)</code></pre><p>Note the <code>ITensor</code> argument to the read function, which tells Julia which read function to call and how to interpret the data stored in the HDF5 dataset named &quot;T&quot;. In the future we might lift the requirement of providing the type and have it be detected automatically from the data stored in the file.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/MPSTimeEvolution.html">« MPS Time Evolution</a><a class="docs-footer-nextpage" href="MPSandMPO.html">MPS and MPO Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 November 2024 13:35">Thursday 14 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
