<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contraction sequence optimization · ITensors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ITensors.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="examples/Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="ITensorType.html">ITensor</a></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="OpSum.html">OpSum (AutoMPO)</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="CodeTiming.html">Timing and profiling</a></li><li class="is-active"><a class="tocitem" href="ContractionSequenceOptimization.html">Contraction sequence optimization</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced Usage Guide</a></li><li class="is-active"><a href="ContractionSequenceOptimization.html">Contraction sequence optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ContractionSequenceOptimization.html">Contraction sequence optimization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/ContractionSequenceOptimization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Contraction-sequence-optimization"><a class="docs-heading-anchor" href="#Contraction-sequence-optimization">Contraction sequence optimization</a><a id="Contraction-sequence-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Contraction-sequence-optimization" title="Permalink"></a></h1><p>When contracting a tensor network, the sequence of contraction makes a big difference in the computational cost. However, the complexity of determining the optimal sequence grows exponentially with the number of tensors, but there are many heuristic algorithms available for computing optimal sequences for small networks<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup><sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup><sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup><sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup><sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>. ITensors.jl provides some functionality for helping you find the optimal contraction sequence for small tensor network, as we will show below.</p><p>The algorithm in ITensors.jl currently uses a modified version of<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> with simplifications for outer product contractions similar to those used in <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ContractionSequenceOptimization.optimal_contraction_sequence" href="#ITensors.ContractionSequenceOptimization.optimal_contraction_sequence"><code>ITensors.ContractionSequenceOptimization.optimal_contraction_sequence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimal_contraction_sequence(T)</code></pre><p>Returns a contraction sequence for contracting the tensors <code>T</code>. The sequence is generally optimal (currently, outer product contractions are skipped, but some optimal sequences require outer product contractions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/408516dce2e0182e04a6fb27b501b04a31b630fc/src/ContractionSequenceOptimization/ContractionSequenceOptimization.jl#L25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ContractionSequenceOptimization.contraction_cost" href="#ITensors.ContractionSequenceOptimization.contraction_cost"><code>ITensors.ContractionSequenceOptimization.contraction_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contraction_cost(A; sequence)</code></pre><p>Return the cost of contracting the collection of ITensors according to the specified sequence, where the cost is measured in the number of floating point operations that would need to be performed to contract dense tensors of the dimensions specified by the indices of the tensors (so for now, sparsity is ignored in computing the costs). Pairwise costs are returned in a vector (contracting <code>N</code> tensors requires <code>N-1</code> pairwise contractions). You can use <code>sum(contraction_cost(A; sequence))</code> to get the total cost of the contraction.</p><p>If no sequence is specified, left associative contraction is used, in other words the sequence is equivalent to <code>[[[[1, 2], 3], 4], …]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/408516dce2e0182e04a6fb27b501b04a31b630fc/src/ContractionSequenceOptimization/contraction_cost.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.contract" href="#NDTensors.contract"><code>NDTensors.contract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">*(As::ITensor...; sequence = default_sequence(), kwargs...)
*(As::Vector{&lt;: ITensor}; sequence = default_sequence(), kwargs...)
contract(As::ITensor...; sequence = default_sequence(), kwargs...)</code></pre><p>Contract the set of ITensors according to the contraction sequence.</p><p>The default sequence is &quot;automatic&quot; if <code>ITensors.using_contraction_sequence_optimization()</code> is true, otherwise it is &quot;left_associative&quot; (the ITensors are contracted from left to right).</p><p>You can change the default with <code>ITensors.enable_contraction_sequence_optimization()</code> and <code>ITensors.disable_contraction_sequence_optimization()</code>.</p><p>For a custom sequence, the sequence should be provided as a binary tree where the leaves are integers <code>n</code> specifying the ITensor <code>As[n]</code> and branches are accessed by indexing with <code>1</code> or <code>2</code>, i.e. <code>sequence = Any[Any[1, 3], Any[2, 4]]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/408516dce2e0182e04a6fb27b501b04a31b630fc/src/tensor_operations/tensor_algebra.jl#L154-L170">source</a></section><section><div><pre><code class="language-julia hljs">contract(ψ::MPS, A::MPO; kwargs...) -&gt; MPS
*(::MPS, ::MPO; kwargs...) -&gt; MPS

contract(A::MPO, ψ::MPS; kwargs...) -&gt; MPS
*(::MPO, ::MPS; kwargs...) -&gt; MPS</code></pre><p>Contract the <code>MPO</code> <code>A</code> with the <code>MPS</code> <code>ψ</code>, returning an <code>MPS</code> with the unique site indices of the <code>MPO</code>.</p><p>For example, for an MPO with site indices with prime levels of 1 and 0, such as <code>-s&#39;-A-s-</code>, and an MPS with site indices with prime levels of 0, such as <code>-s-x</code>, the result is an MPS <code>y</code> with site indices with prime levels of 1, <code>-s&#39;-y = -s&#39;-A-s-x</code>.</p><p>Since it is common to contract an MPO with prime levels of 1 and 0 with an MPS with prime level of 0 and want a resulting MPS with prime levels of 0, we provide a convenience function <code>apply</code>:</p><pre><code class="language-julia hljs">apply(A, x; kwargs...) = replaceprime(contract(A, x; kwargs...), 2 =&gt; 1)`.</code></pre><p>Choose the method with the <code>method</code> keyword, for example <code>&quot;densitymatrix&quot;</code> and <code>&quot;naive&quot;</code>.</p><p><strong>Keywords</strong></p><ul><li><code>cutoff::Float64=1e-13</code>: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to  change, in general you should set a <code>cutoff</code> value.</li><li><code>maxdim::Int=maxlinkdim(A) * maxlinkdim(ψ))</code>: the maximal bond dimension of the results MPS.</li><li><code>mindim::Int=1</code>: the minimal bond dimension of the resulting MPS.</li><li><code>normalize::Bool=false</code>: whether or not to normalize the resulting MPS.</li><li><code>method::String=&quot;densitymatrix&quot;</code>: the algorithm to use for the contraction.  Currently the options are &quot;densitymatrix&quot;, where the network formed by the  MPO and MPS is squared and contracted down to a density matrix which is  diagonalized iteratively at each site, and &quot;naive&quot;, where the MPO and MPS  tensor are contracted exactly at each site and then a truncation of the  resulting MPS is performed.</li></ul><p>See also <a href="MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}"><code>apply</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/408516dce2e0182e04a6fb27b501b04a31b630fc/src/mps/mpo.jl#L660-L700">source</a></section><section><div><pre><code class="language-julia hljs">contract(A::MPO, B::MPO; kwargs...) -&gt; MPO
*(::MPO, ::MPO; kwargs...) -&gt; MPO</code></pre><p>Contract the <code>MPO</code> <code>A</code> with the <code>MPO</code> <code>B</code>, returning an <code>MPO</code> with the site indices that are not shared between <code>A</code> and <code>B</code>.</p><p>If you are contracting two MPOs with the same sets of indices, likely you want to call something like:</p><pre><code class="language-julia hljs">C = contract(A&#39;, B; cutoff=1e-12)
C = replaceprime(C, 2 =&gt; 1)</code></pre><p>That is because if MPO <code>A</code> has the index structure <code>-s&#39;-A-s-</code> and MPO <code>B</code> has the Index structure <code>-s&#39;-B-s-</code>, if we only want to contract over on set of the indices, we would do <code>(-s&#39;-A-s-)&#39;-s&#39;-B-s- = -s&#39;&#39;-A-s&#39;-s&#39;-B-s- = -s&#39;&#39;-C-s-</code>, and then map the prime levels back to pairs of primed and unprimed indices with: <code>replaceprime(-s&#39;&#39;-C-s-, 2 =&gt; 1) = -s&#39;-C-s-</code>.</p><p>Since this is a common use case, you can use the convenience function:</p><pre><code class="language-julia hljs">C = apply(A, B; cutoff=1e-12)</code></pre><p>which is the same as the code above.</p><p>If you are contracting MPOs that have diverging norms, such as MPOs representing sums of local operators, the truncation can become numerically unstable (see https://arxiv.org/abs/1909.06341 for a more numerically stable alternative). For now, you can use the following options to contract MPOs like that:</p><pre><code class="language-julia hljs">C = contract(A, B; alg=&quot;naive&quot;, truncate=false)
# Bring the indices back to pairs of primed and unprimed
C = apply(A, B; alg=&quot;naive&quot;, truncate=false)</code></pre><p><strong>Keywords</strong></p><ul><li><code>cutoff::Float64=1e-14</code>: the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to change,  in general you should set a <code>cutoff</code> value.</li><li><code>maxdim::Int=maxlinkdim(A) * maxlinkdim(B))</code>: the maximal bond dimension of the results MPS.</li><li><code>mindim::Int=1</code>: the minimal bond dimension of the resulting MPS.</li><li><code>alg=&quot;zipup&quot;</code>: Either <code>&quot;zipup&quot;</code> or <code>&quot;naive&quot;</code>. <code>&quot;zipup&quot;</code> contracts pairs of  site tensors and truncates with SVDs in a sweep across the sites, while <code>&quot;naive&quot;</code>  first contracts pairs of tensor exactly and then truncates at the end if <code>truncate=true</code>.</li><li><code>truncate=true</code>: Enable or disable truncation. If <code>truncate=false</code>, ignore  other truncation parameters like <code>cutoff</code> and <code>maxdim</code>. This is most relevant  for the <code>&quot;naive&quot;</code> version, if you just want to contract the tensors pairwise  exactly. This can be useful if you are contracting MPOs that have diverging  norms, such as MPOs originating from sums of local operators.</li></ul><p>See also <a href="MPSandMPO.html#ITensors.apply-Tuple{MPO, MPS}"><code>apply</code></a> for details about the arguments available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/408516dce2e0182e04a6fb27b501b04a31b630fc/src/mps/mpo.jl#L946-L1002">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>In the following example we show how to compute the contraction sequence cost of a </p><pre><code class="language- hljs">using ITensors
using Symbolics

using ITensors: contraction_cost

@variables m, k, d

l = Index(m, &quot;l&quot;)
r = Index(m, &quot;r&quot;)
h₁ = Index(k, &quot;h₁&quot;)
h₂ = Index(k, &quot;h₂&quot;)
h₃ = Index(k, &quot;h₃&quot;)
s₁ = Index(d, &quot;s₁&quot;)
s₂ = Index(d, &quot;s₂&quot;)

H₁ = emptyITensor(dag(s₁), s₁&#39;, dag(h₁), h₂)
H₂ = emptyITensor(dag(s₂), s₂&#39;, dag(h₂), h₃)
L = emptyITensor(dag(l), l&#39;, h₁)
R = emptyITensor(dag(r), r&#39;, h₃)
ψ = emptyITensor(l, s₁, s₂, r)

TN = [ψ, L, H₁, H₂, R]
sequence1 = Any[2, Any[3, Any[4, Any[1, 5]]]]
sequence2 = Any[Any[4, 5], Any[1, Any[2, 3]]]
cost1 = contraction_cost(TN; sequence = sequence1)
cost2 = contraction_cost(TN; sequence = sequence2)

println(&quot;First sequence&quot;)
display(sequence1)
display(cost1)
@show sum(cost1)
@show substitute(sum(cost1), Dict(d =&gt; 4))

println(&quot;\nSecond sequence&quot;)
display(sequence2)
display(cost2)
@show sum(cost2)
@show substitute(sum(cost2), Dict(d =&gt; 4))</code></pre><p>This example helps us learn that in the limit of large MPS bond dimension <code>m</code>, the first contraction sequence is faster, while in the limit of large MPO bond dimension <code>k</code>, the second sequence is faster. This has practical implications for writing an efficient DMRG algorithm in both limits, which we plan to incorporate into ITensors.jl.</p><p>Here is a more systematic example of searching through the parameter space to find optimal contraction sequences:</p><pre><code class="language-julia hljs">using ITensors
using Symbolics

using ITensors: contraction_cost, optimal_contraction_sequence

function tensor_network(; m, k, d)
  l = Index(m, &quot;l&quot;)
  r = Index(m, &quot;r&quot;)
  h₁ = Index(k, &quot;h₁&quot;)
  h₂ = Index(k, &quot;h₂&quot;)
  h₃ = Index(k, &quot;h₃&quot;)
  s₁ = Index(d, &quot;s₁&quot;)
  s₂ = Index(d, &quot;s₂&quot;)

  ψ = emptyITensor(l, s₁, s₂, r)
  L = emptyITensor(dag(l), l&#39;, h₁)
  H₁ = emptyITensor(dag(s₁), s₁&#39;, dag(h₁), h₂)
  H₂ = emptyITensor(dag(s₂), s₂&#39;, dag(h₂), h₃)
  R = emptyITensor(dag(r), r&#39;, h₃)
  return [ψ, L, H₁, H₂, R]
end

function main()
  mrange = 50:10:80
  krange = 50:10:80
  sequence_costs = Matrix{Any}(undef, length(mrange), length(krange))
  for iₘ in eachindex(mrange), iₖ in eachindex(krange)
    m_val = mrange[iₘ]
    k_val = krange[iₖ]
    d_val = 4

    TN = tensor_network(; m = m_val, k = k_val, d = d_val)
    sequence = optimal_contraction_sequence(TN)
    cost = contraction_cost(TN; sequence = sequence)

    @variables m, k, d
    TN_symbolic = tensor_network(; m = m, k = k, d = d)
    cost_symbolic = contraction_cost(TN_symbolic; sequence = sequence)
    sequence_cost = (dims = (m = m_val, k = k_val, d = d_val), sequence = sequence, cost = cost, symbolic_cost = cost_symbolic)
    sequence_costs[iₘ, iₖ] = sequence_cost
  end
  return sequence_costs
end

sequence_costs = main()

# Analyze the results.
println(&quot;Index dimensions&quot;)
display(getindex.(sequence_costs, :dims))

println(&quot;\nContraction sequences&quot;)
display(getindex.(sequence_costs, :sequence))

println(&quot;\nSymbolic contraction cost with d = 4&quot;)
# Fix d to a certain value (such as 4 for a Hubbard site)
@variables d
var_sub = Dict(d =&gt; 4)
display(substitute.(sum.(getindex.(sequence_costs, :symbolic_cost)), (var_sub,)))</code></pre><p>A future direction will be to allow optimizing over contraction sequences with the dimensions specified symbolically, so that the optimal sequence in limits of certain dimensions can be found. In addition, we plan to implement more algorithms that work for larger networks, as well as algorithms like<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> which take an optimal sequence for a closed network and generate optimal sequences for environments of each tensor in the network, which is helpful for computing gradients of tensor networks.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://arxiv.org/abs/1304.6112">Faster identification of optimal contraction sequences for tensor networks</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://arxiv.org/abs/1310.8023">Improving the efficiency of variational tensor network algorithms</a></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://arxiv.org/abs/quant-ph/0511069">Simulating quantum computation by contracting tensor networks</a></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.043309">Towards a polynomial algorithm for optimal contraction sequence of tensor networks from trees</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a><a href="https://arxiv.org/abs/2001.08063">Algorithms for Tensor Network Contraction Ordering</a></li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="CodeTiming.html">« Timing and profiling</a><a class="docs-footer-nextpage" href="HDF5FileFormats.html">HDF5 File Formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 17 November 2023 16:47">Friday 17 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
