<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ITensor · ITensors.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ITensors.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ITensors.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="getting_started/Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="getting_started/RunningCodes.html">Running ITensor and Julia Codes</a></li><li><a class="tocitem" href="getting_started/DebugChecks.html">Enabling Debug Checks</a></li><li><a class="tocitem" href="getting_started/NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/DMRG.html">DMRG</a></li><li><a class="tocitem" href="tutorials/QN_DMRG.html">Quantum Number Conserving DMRG</a></li><li><a class="tocitem" href="tutorials/MPSTimeEvolution.html">MPS Time Evolution</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="examples/Physics.html">Physics (SiteType) System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexSetType.html">Index collections</a></li><li class="is-active"><a class="tocitem" href="ITensorType.html">ITensor</a><ul class="internal"><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Dense-Constructors"><span>Dense Constructors</span></a></li><li><a class="tocitem" href="#Dense-View-Constructors"><span>Dense View Constructors</span></a></li><li><a class="tocitem" href="#QN-BlockSparse-Constructors"><span>QN BlockSparse Constructors</span></a></li><li><a class="tocitem" href="#Diagonal-constructors"><span>Diagonal constructors</span></a></li><li><a class="tocitem" href="#QN-Diagonal-constructors"><span>QN Diagonal constructors</span></a></li><li><a class="tocitem" href="#Convert-to-Array"><span>Convert to Array</span></a></li><li><a class="tocitem" href="#Getting-and-setting-elements"><span>Getting and setting elements</span></a></li><li><a class="tocitem" href="#Properties"><span>Properties</span></a></li><li><a class="tocitem" href="#Priming_and_tagging_ITensor"><span>Priming and tagging</span></a></li><li><a class="tocitem" href="#Index-collections-set-operations"><span>Index collections set operations</span></a></li><li><a class="tocitem" href="#Index-Manipulations"><span>Index Manipulations</span></a></li><li><a class="tocitem" href="#Math-operations"><span>Math operations</span></a></li><li><a class="tocitem" href="#Decompositions"><span>Decompositions</span></a></li><li><a class="tocitem" href="#Memory-operations"><span>Memory operations</span></a></li></ul></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="SiteType.html">SiteType and op, state, val functions</a></li><li><a class="tocitem" href="IncludedSiteTypes.html">SiteTypes Included with ITensor</a></li><li><input class="collapse-toggle" id="menuitem-5-8" type="checkbox"/><label class="tocitem" for="menuitem-5-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="OpSum.html">OpSum (AutoMPO)</a></li></ul></li><li><span class="tocitem">Frequently Asked Questions</span><ul><li><a class="tocitem" href="faq/JuliaAndCpp.html">Programming Language (Julia, C++, ...) FAQs</a></li><li><a class="tocitem" href="faq/DMRG.html">DMRG FAQs</a></li><li><a class="tocitem" href="faq/QN.html">Quantum Number (QN) FAQs</a></li><li><a class="tocitem" href="faq/Development.html">ITensor Development FAQs</a></li><li><a class="tocitem" href="faq/RelationshipToOtherLibraries.html">Relationship of ITensor to other tensor libraries FAQs</a></li><li><a class="tocitem" href="faq/JuliaPkg.html">Julia Package Manager FAQs</a></li><li><a class="tocitem" href="faq/HPC.html">High-Performance Computing FAQs</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced Usage Guide</span><ul><li><a class="tocitem" href="AdvancedUsageGuide.html">Advanced Usage Guide</a></li><li><a class="tocitem" href="Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="QNTricks.html">Symmetric (QN conserving) tensors: background and usage</a></li><li><a class="tocitem" href="CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="ContractionSequenceOptimization.html">Contraction sequence optimization</a></li><li><a class="tocitem" href="HDF5FileFormats.html">HDF5 File Formats</a></li></ul></li><li><a class="tocitem" href="DeveloperGuide.html">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/main/docs/src/ITensorType.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ITensor"><a class="docs-heading-anchor" href="#ITensor">ITensor</a><a id="ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#ITensor" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor" href="#ITensors.ITensor"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ITensor(st::TensorStorage, is)</code></pre><p>Constructor for an ITensor from a TensorStorage and a set of indices. The ITensor stores a view of the TensorStorage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L111-L117">source</a></section><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64, ]inds)
ITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(4,&quot;index_j&quot;)
k = Index(3,&quot;index_k&quot;)

A = ITensor(i,j)
B = ITensor(ComplexF64,k,j)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L156-L175">source</a></section><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)
ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>. One purpose for using this constructor is that initializing the elements in an   undefined way is faster than initializing them to a set value such as zero.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(4,&quot;index_j&quot;)
k = Index(3,&quot;index_k&quot;)

A = ITensor(undef,i,j)
B = ITensor(ComplexF64,undef,k,j)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L193-L214">source</a></section><section><div><pre><code class="language-julia hljs">ITensor([ElT::Type, ]x::Number, inds)
ITensor([ElT::Type, ]x::Number, inds::Index...)</code></pre><p>Construct an ITensor with all elements set to <code>x</code> and indices <code>inds</code>.</p><p>If <code>x isa Int</code> or <code>x isa Complex{Int}</code> then the elements will be set to <code>float(x)</code>   unless specified otherwise by the first input.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><p>```julia   i = Index(2,&quot;index<em>i&quot;); j = Index(4,&quot;index</em>j&quot;); k = Index(3,&quot;index_k&quot;);</p><p>A = ITensor(1.0, i, j)   A = ITensor(1, i, j) # same as above   B = ITensor(2.0+3.0im, j, k)   ```</p><p>!!! warning       In future versions this may not automatically convert integer inputs with <code>float</code>, and in that case the particular element type should not be relied on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L227-L250">source</a></section><section><div><pre><code class="language-julia hljs">ITensor([ElT::Type, ]A::Array, inds)
ITensor([ElT::Type, ]A::Array, inds::Index...)

itensor([ElT::Type, ]A::Array, inds)
itensor([ElT::Type, ]A::Array, inds::Index...)</code></pre><p>Construct an ITensor from an Array <code>A</code> and indices <code>inds</code>. The ITensor will be a view of the Array data if possible (if no conversion to a different element type is necessary).</p><p>If specified, the ITensor will have element type <code>ElT</code>.</p><p>If the element type of <code>A</code> is <code>Int</code> or <code>Complex{Int}</code> and the desired element type isn&#39;t specified, it will be converted to <code>Float64</code> or <code>Complex{Float64}</code> automatically. To keep the element type as an integer, specify it explicitly, for example with:</p><pre><code class="language-julia hljs">i = Index(2, &quot;i&quot;)
A = [0 1; 1 0]
T = ITensor(eltype(A), A, i&#39;, dag(i))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(2,&quot;index_j&quot;)

M = [1. 2;
     3 4]
T = ITensor(M, i, j)
T[i =&gt; 1, j =&gt; 1] = 3.3
M[1, 1] == 3.3
T[i =&gt; 1, j =&gt; 1] == 3.3</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In future versions this may not automatically convert <code>Int</code>/<code>Complex{Int}</code> inputs to floating point versions with <code>float</code> (once tensor operations using <code>Int</code>/<code>Complex{Int}</code> are natively as fast as floating point operations), and in that case the particular element type should not be relied on. To avoid extra conversions (and therefore allocations) it is best practice to directly construct with <code>itensor([0. 1; 1 0], i&#39;, dag(i))</code> if you want a floating point element type. The conversion is done as a performance optimization since often tensors are passed to BLAS/LAPACK and need to be converted to floating point types compatible with those libraries, but future projects in Julia may allow for efficient operations with more general element types (for example see https://github.com/JuliaLinearAlgebra/Octavian.jl).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L295-L335">source</a></section><section><div><pre><code class="nohighlight hljs">ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)
ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)</code></pre><p>Construct an ITensor with BlockSparse storage filled with <code>zero(ElT)</code> where the nonzero blocks are determined by <code>flux</code>.</p><p>If <code>ElT</code> is not specified it defaults to <code>Float64</code>.</p><p>If <code>flux</code> is not specified, the ITensor will be empty (it will contain no blocks, and have an undefined flux). The flux will be set by the first element that is set.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; i
(dim=3|id=212|&quot;i&quot;) &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2

julia&gt; @show ITensor(QN(0), i&#39;, dag(i));
ITensor(QN(0), i&#39;, dag(i)) = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64, Vector{Float64}, 2}
 3×3
Block(1, 1)
 [1:1, 1:1]
 0.0

Block(2, 2)
 [2:3, 2:3]
 0.0  0.0
 0.0  0.0

julia&gt; @show ITensor(QN(1), i&#39;, dag(i));
ITensor(QN(1), i&#39;, dag(i)) = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64, Vector{Float64}, 2}
 3×3
Block(2, 1)
 [2:3, 1:1]
 0.0
 0.0

julia&gt; @show ITensor(ComplexF64, QN(1), i&#39;, dag(i));
ITensor(ComplexF64, QN(1), i&#39;, dag(i)) = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{ComplexF64, Vector{ComplexF64}, 2}
 3×3
Block(2, 1)
 [2:3, 1:1]
 0.0 + 0.0im
 0.0 + 0.0im

julia&gt; @show ITensor(undef, QN(1), i&#39;, dag(i));
ITensor(undef, QN(1), i&#39;, dag(i)) = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64, Vector{Float64}, 2}
 3×3
Block(2, 1)
 [2:3, 1:1]
 0.0
 1.63e-322</code></pre><p>Construction with undefined flux:</p><pre><code class="language-julia hljs">julia&gt; A = ITensor(i&#39;, dag(i));

julia&gt; @show A;
A = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.EmptyStorage{NDTensors.EmptyNumber, NDTensors.BlockSparse{NDTensors.EmptyNumber, Vector{NDTensors.EmptyNumber}, 2}}
 3×3



julia&gt; isnothing(flux(A))
true

julia&gt; A[i&#39; =&gt; 1, i =&gt; 2] = 2
2

julia&gt; @show A;
A = ITensor ord=2
Dim 1: (dim=3|id=212|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=212|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Int64, Vector{Int64}, 2}
 3×3
Block(1, 2)
 [1:1, 2:3]
 2  0

julia&gt; flux(A)
QN(-1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L14-L138">source</a></section><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds)
ITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds::Index...)</code></pre><p>Construct an ITensor with indices <code>inds</code> and BlockSparse storage with undefined elements of type <code>ElT</code>, where the nonzero (allocated) blocks are determined by the provided QN <code>flux</code>. One purpose for using this constructor is that initializing the elements in an undefined way is faster than initializing them to a set value such as zero.</p><p>The storage will have <code>NDTensors.BlockSparse</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index([QN(0)=&gt;1, QN(1)=&gt;2], &quot;i&quot;)
A = ITensor(undef,QN(0),i&#39;,dag(i))
B = ITensor(Float64,undef,QN(0),i&#39;,dag(i))
C = ITensor(ComplexF64,undef,QN(0),i&#39;,dag(i))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L171-L191">source</a></section><section><div><pre><code class="nohighlight hljs">ITensor([ElT::Type, ]x::Number, flux::QN, inds)
ITensor([ElT::Type, ]x::Number, flux::QN, inds::Index...)</code></pre><p>Construct an ITensor with all elements consistent with QN flux <code>flux</code> set to <code>x</code> and indices <code>inds</code>.</p><p>If <code>x isa Int</code> or <code>x isa Complex{Int}</code> then the elements will be set to <code>float(x)</code> unless specified otherwise by the first input.</p><p>The storage will have <code>NDTensors.BlockSparse</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index([QN(0)=&gt;1, QN(1)=&gt;2], &quot;i&quot;)
A = ITensor(2.3, QN(0), i&#39;, dag(i))
B = ITensor(Float64, 3.5, QN(0), i&#39;, dag(i))
C = ITensor(ComplexF64, 4, QN(0), i&#39;, dag(i))</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In future versions this may not automatically convert integer inputs with <code>float</code>, and in that case the particular element type should not be relied on.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L209-L232">source</a></section><section><div><pre><code class="nohighlight hljs">ITensor([ElT::Type, ]::AbstractArray, inds; tol=0.0, checkflux=true)</code></pre><p>Create a block sparse ITensor from the input Array, and collection of QN indices. Zeros are dropped and nonzero blocks are determined from the zero values of the array.</p><p>Optionally, you can set a tolerance such that elements less than or equal to the tolerance are dropped.</p><p>By default, this will check that the flux of the nonzero blocks are consistent with each other. You can disable this check by setting <code>checkflux=false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; i = Index([QN(0)=&gt;1, QN(1)=&gt;2], &quot;i&quot;);

julia&gt; A = [1e-9 0.0 0.0;
            0.0 2.0 3.0;
            0.0 1e-10 4.0];

julia&gt; @show ITensor(A, i&#39;, dag(i); tol = 1e-8);
ITensor(A, i&#39;, dag(i); tol = 1.0e-8) = ITensor ord=2
Dim 1: (dim=3|id=468|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=468|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64,Array{Float64,1},2}
 3×3
Block: (2, 2)
 [2:3, 2:3]
 2.0  3.0
 0.0  4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L258-L296">source</a></section></article><h2 id="Dense-Constructors"><a class="docs-heading-anchor" href="#Dense-Constructors">Dense Constructors</a><a id="Dense-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.ITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64, ]inds)
ITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(4,&quot;index_j&quot;)
k = Index(3,&quot;index_k&quot;)

A = ITensor(i,j)
B = ITensor(ComplexF64,k,j)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L156-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{&lt;:Number}, UndefInitializer, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.ITensor-Tuple{Type{&lt;:Number}, UndefInitializer, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)
ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>. One purpose for using this constructor is that initializing the elements in an   undefined way is faster than initializing them to a set value such as zero.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(4,&quot;index_j&quot;)
k = Index(3,&quot;index_k&quot;)

A = ITensor(undef,i,j)
B = ITensor(ComplexF64,undef,k,j)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L193-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{&lt;:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.ITensor-Tuple{Type{&lt;:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([ElT::Type, ]x::Number, inds)
ITensor([ElT::Type, ]x::Number, inds::Index...)</code></pre><p>Construct an ITensor with all elements set to <code>x</code> and indices <code>inds</code>.</p><p>If <code>x isa Int</code> or <code>x isa Complex{Int}</code> then the elements will be set to <code>float(x)</code>   unless specified otherwise by the first input.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p><p><strong>Examples</strong></p><p>```julia   i = Index(2,&quot;index<em>i&quot;); j = Index(4,&quot;index</em>j&quot;); k = Index(3,&quot;index_k&quot;);</p><p>A = ITensor(1.0, i, j)   A = ITensor(1, i, j) # same as above   B = ITensor(2.0+3.0im, j, k)   ```</p><p>!!! warning       In future versions this may not automatically convert integer inputs with <code>float</code>, and in that case the particular element type should not be relied on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L227-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Array{&lt;:Number}, Union{Tuple{Vararg{Index{Int64}}}, Vector{Index{Int64}}}}" href="#ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Array{&lt;:Number}, Union{Tuple{Vararg{Index{Int64}}}, Vector{Index{Int64}}}}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([ElT::Type, ]A::Array, inds)
ITensor([ElT::Type, ]A::Array, inds::Index...)

itensor([ElT::Type, ]A::Array, inds)
itensor([ElT::Type, ]A::Array, inds::Index...)</code></pre><p>Construct an ITensor from an Array <code>A</code> and indices <code>inds</code>. The ITensor will be a view of the Array data if possible (if no conversion to a different element type is necessary).</p><p>If specified, the ITensor will have element type <code>ElT</code>.</p><p>If the element type of <code>A</code> is <code>Int</code> or <code>Complex{Int}</code> and the desired element type isn&#39;t specified, it will be converted to <code>Float64</code> or <code>Complex{Float64}</code> automatically. To keep the element type as an integer, specify it explicitly, for example with:</p><pre><code class="language-julia hljs">i = Index(2, &quot;i&quot;)
A = [0 1; 1 0]
T = ITensor(eltype(A), A, i&#39;, dag(i))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(2,&quot;index_j&quot;)

M = [1. 2;
     3 4]
T = ITensor(M, i, j)
T[i =&gt; 1, j =&gt; 1] = 3.3
M[1, 1] == 3.3
T[i =&gt; 1, j =&gt; 1] == 3.3</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In future versions this may not automatically convert <code>Int</code>/<code>Complex{Int}</code> inputs to floating point versions with <code>float</code> (once tensor operations using <code>Int</code>/<code>Complex{Int}</code> are natively as fast as floating point operations), and in that case the particular element type should not be relied on. To avoid extra conversions (and therefore allocations) it is best practice to directly construct with <code>itensor([0. 1; 1 0], i&#39;, dag(i))</code> if you want a floating point element type. The conversion is done as a performance optimization since often tensors are passed to BLAS/LAPACK and need to be converted to floating point types compatible with those libraries, but future projects in Julia may allow for efficient operations with more general element types (for example see https://github.com/JuliaLinearAlgebra/Octavian.jl).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L295-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.randomITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.randomITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.randomITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds)
randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with type <code>ElT</code> and indices <code>inds</code>, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to <code>Float64</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(4,&quot;index_j&quot;)
k = Index(3,&quot;index_k&quot;)

A = randomITensor(i,j)
B = randomITensor(ComplexF64,undef,k,j)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L601-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.onehot" href="#ITensors.onehot"><code>ITensors.onehot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">onehot(ivs...)
setelt(ivs...)
onehot(::Type, ivs...)
setelt(::Type, ivs...)</code></pre><p>Create an ITensor with all zeros except the specified value, which is set to 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;i&quot;)
A = onehot(i=&gt;2)
# A[i=&gt;2] == 1, all other elements zero

# Specify the element type
A = onehot(Float32, i=&gt;2)

j = Index(3,&quot;j&quot;)
B = onehot(i=&gt;1,j=&gt;3)
# B[i=&gt;1,j=&gt;3] == 1, all other element zero</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L544-L566">source</a></section></article><h2 id="Dense-View-Constructors"><a class="docs-heading-anchor" href="#Dense-View-Constructors">Dense View Constructors</a><a id="Dense-View-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-View-Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.itensor-Tuple{Array{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.itensor-Tuple{Array{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.itensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">itensor(args...; kwargs...)</code></pre><p>Like the <code>ITensor</code> constructor, but with attempt to make a view of the input data when possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L128-L133">source</a></section></article><h2 id="QN-BlockSparse-Constructors"><a class="docs-heading-anchor" href="#QN-BlockSparse-Constructors">QN BlockSparse Constructors</a><a id="QN-BlockSparse-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#QN-BlockSparse-Constructors" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ITensor(::Type{&lt;:Number}, ::QN, ::ITensors.Indices)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Array{&lt;:Number}, Union{Tuple{Vararg{Index{Vector{Pair{QN, Int64}}}}}, Vector{Index{Vector{Pair{QN, Int64}}}}}}" href="#ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Array{&lt;:Number}, Union{Tuple{Vararg{Index{Vector{Pair{QN, Int64}}}}}, Vector{Index{Vector{Pair{QN, Int64}}}}}}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([ElT::Type, ]A::Array, inds)
ITensor([ElT::Type, ]A::Array, inds::Index...)

itensor([ElT::Type, ]A::Array, inds)
itensor([ElT::Type, ]A::Array, inds::Index...)</code></pre><p>Construct an ITensor from an Array <code>A</code> and indices <code>inds</code>. The ITensor will be a view of the Array data if possible (if no conversion to a different element type is necessary).</p><p>If specified, the ITensor will have element type <code>ElT</code>.</p><p>If the element type of <code>A</code> is <code>Int</code> or <code>Complex{Int}</code> and the desired element type isn&#39;t specified, it will be converted to <code>Float64</code> or <code>Complex{Float64}</code> automatically. To keep the element type as an integer, specify it explicitly, for example with:</p><pre><code class="language-julia hljs">i = Index(2, &quot;i&quot;)
A = [0 1; 1 0]
T = ITensor(eltype(A), A, i&#39;, dag(i))</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;)
j = Index(2,&quot;index_j&quot;)

M = [1. 2;
     3 4]
T = ITensor(M, i, j)
T[i =&gt; 1, j =&gt; 1] = 3.3
M[1, 1] == 3.3
T[i =&gt; 1, j =&gt; 1] == 3.3</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>In future versions this may not automatically convert <code>Int</code>/<code>Complex{Int}</code> inputs to floating point versions with <code>float</code> (once tensor operations using <code>Int</code>/<code>Complex{Int}</code> are natively as fast as floating point operations), and in that case the particular element type should not be relied on. To avoid extra conversions (and therefore allocations) it is best practice to directly construct with <code>itensor([0. 1; 1 0], i&#39;, dag(i))</code> if you want a floating point element type. The conversion is done as a performance optimization since often tensors are passed to BLAS/LAPACK and need to be converted to floating point types compatible with those libraries, but future projects in Julia may allow for efficient operations with more general element types (for example see https://github.com/JuliaLinearAlgebra/Octavian.jl).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L295-L335">source</a></section><section><div><pre><code class="nohighlight hljs">ITensor([ElT::Type, ]::AbstractArray, inds; tol=0.0, checkflux=true)</code></pre><p>Create a block sparse ITensor from the input Array, and collection of QN indices. Zeros are dropped and nonzero blocks are determined from the zero values of the array.</p><p>Optionally, you can set a tolerance such that elements less than or equal to the tolerance are dropped.</p><p>By default, this will check that the flux of the nonzero blocks are consistent with each other. You can disable this check by setting <code>checkflux=false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; i = Index([QN(0)=&gt;1, QN(1)=&gt;2], &quot;i&quot;);

julia&gt; A = [1e-9 0.0 0.0;
            0.0 2.0 3.0;
            0.0 1e-10 4.0];

julia&gt; @show ITensor(A, i&#39;, dag(i); tol = 1e-8);
ITensor(A, i&#39;, dag(i); tol = 1.0e-8) = ITensor ord=2
Dim 1: (dim=3|id=468|&quot;i&quot;)&#39; &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=468|&quot;i&quot;) &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64,Array{Float64,1},2}
 3×3
Block: (2, 2)
 [2:3, 2:3]
 2.0  3.0
 0.0  4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L258-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.ITensor-Tuple{Type{&lt;:Number}, UndefInitializer, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.ITensor-Tuple{Type{&lt;:Number}, UndefInitializer, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds)
ITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds::Index...)</code></pre><p>Construct an ITensor with indices <code>inds</code> and BlockSparse storage with undefined elements of type <code>ElT</code>, where the nonzero (allocated) blocks are determined by the provided QN <code>flux</code>. One purpose for using this constructor is that initializing the elements in an undefined way is faster than initializing them to a set value such as zero.</p><p>The storage will have <code>NDTensors.BlockSparse</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index([QN(0)=&gt;1, QN(1)=&gt;2], &quot;i&quot;)
A = ITensor(undef,QN(0),i&#39;,dag(i))
B = ITensor(Float64,undef,QN(0),i&#39;,dag(i))
C = ITensor(ComplexF64,undef,QN(0),i&#39;,dag(i))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L171-L191">source</a></section></article><h2 id="Diagonal-constructors"><a class="docs-heading-anchor" href="#Diagonal-constructors">Diagonal constructors</a><a id="Diagonal-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.diagITensor-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagITensor([::Type{ElT} = Float64, ]inds)
diagITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a sparse ITensor of element type <code>ElT</code> with only elements along the diagonal stored. Defaults to having <code>zero(T)</code> along the diagonal.</p><p>The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L419-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Vector{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.diagITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Vector{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagITensor([ElT::Type, ]v::Vector, inds...)
diagitensor([ElT::Type, ]v::Vector, inds...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal. In general, the diagonal elements will be those stored in <code>v</code> and the ITensor will have element type <code>eltype(v)</code>, unless specified explicitly by <code>ElT</code>. The storage will have <code>NDTensors.Diag</code> type.</p><p>In the case when <code>eltype(v) isa Union{Int, Complex{Int}}</code>, by default it will be converted to <code>float(v)</code>. Note that this behavior is subject to change in the future.</p><p>The version <code>diagITensor</code> will never output an ITensor whose storage data is an alias of the input vector data.</p><p>The version <code>diagitensor</code> might output an ITensor whose storage data is an alias of the input vector data in order to minimize operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L438-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.diagITensor-Tuple{NDTensors.AliasStyle, Type{&lt;:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagITensor([ElT::Type, ]x::Number, inds...)
diagitensor([ElT::Type, ]x::Number, inds...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal. In general, the diagonal elements will be set to the value <code>x</code> and the ITensor will have element type <code>eltype(x)</code>, unless specified explicitly by <code>ElT</code>. The storage will have <code>NDTensors.Diag</code> type.</p><p>In the case when <code>x isa Union{Int, Complex{Int}}</code>, by default it will be converted to <code>float(x)</code>. Note that this behavior is subject to change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L488-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.delta-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.delta-Tuple{Type{&lt;:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delta([::Type{ElT} = Float64, ]inds)
delta([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a uniform diagonal ITensor with all diagonal elements <code>one(ElT)</code>. Only a single diagonal element is stored.</p><p>This function has an alias <code>δ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L523-L531">source</a></section></article><h2 id="QN-Diagonal-constructors"><a class="docs-heading-anchor" href="#QN-Diagonal-constructors">QN Diagonal constructors</a><a id="QN-Diagonal-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#QN-Diagonal-constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.diagITensor-Tuple{Type{&lt;:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.diagITensor-Tuple{Type{&lt;:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with elements <code>zero(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L439-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.delta-Tuple{Type{&lt;:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}" href="#ITensors.delta-Tuple{Type{&lt;:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with uniform elements <code>one(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/qn/qnitensor.jl#L489-L499">source</a></section></article><h2 id="Convert-to-Array"><a class="docs-heading-anchor" href="#Convert-to-Array">Convert to Array</a><a id="Convert-to-Array-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-to-Array" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}} where {ElT, N}" href="#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT&lt;:Index}} where {ElT, N}"><code>Core.Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Array{ElT, N}(T::ITensor, i:Index...)
Array{ElT}(T::ITensor, i:Index...)
Array(T::ITensor, i:Index...)

Matrix{ElT}(T::ITensor, row_i:Index, col_i::Index)
Matrix(T::ITensor, row_i:Index, col_i::Index)

Vector{ElT}(T::ITensor)
Vector(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with indices <code>i...</code>, returns an Array with a copy of the ITensor&#39;s elements. The order in which the indices are provided indicates the order of the data in the resulting Array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L696-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.array-Tuple{ITensor, Vararg{Any}}" href="#NDTensors.array-Tuple{ITensor, Vararg{Any}}"><code>NDTensors.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array(T::ITensor, inds...)</code></pre><p>Convert an ITensor <code>T</code> to an Array.</p><p>The ordering of the elements in the Array are specified by the input indices <code>inds</code>. This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor&#39;s storage is Dense and the indices are already in the specified ordering so that no permutation is required.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that in the future we may return specialized AbstractArray types for certain storage types, for example a <code>LinearAlgebra.Diagonal</code> type for an ITensor with <code>Diag</code> storage. The specific storage type shouldn&#39;t be relied upon.</p></div></div><p>See also <a href="ITensorType.html#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}"><code>matrix</code></a>, <a href="ITensorType.html#NDTensors.vector-Tuple{ITensor, Vararg{Any}}"><code>vector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L138-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.matrix-Tuple{ITensor, Vararg{Any}}" href="#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}"><code>NDTensors.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(T::ITensor, inds...)</code></pre><p>Convert an ITensor <code>T</code> to a Matrix.</p><p>The ordering of the elements in the Matrix are specified by the input indices <code>inds</code>. This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor&#39;s storage is Dense and the indices are already in the specified ordering so that no permutation is required.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that in the future we may return specialized AbstractArray types for certain storage types, for example a <code>LinearAlgebra.Diagonal</code> type for an ITensor with <code>Diag</code> storage. The specific storage type shouldn&#39;t be relied upon.</p></div></div><p>See also <a href="ITensorType.html#NDTensors.array-Tuple{ITensor, Vararg{Any}}"><code>array</code></a>, <a href="ITensorType.html#NDTensors.vector-Tuple{ITensor, Vararg{Any}}"><code>vector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L186-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.vector-Tuple{ITensor, Vararg{Any}}" href="#NDTensors.vector-Tuple{ITensor, Vararg{Any}}"><code>NDTensors.vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector(T::ITensor, inds...)</code></pre><p>Convert an ITensor <code>T</code> to an Vector.</p><p>The ordering of the elements in the Array are specified by the input indices <code>inds</code>. This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor&#39;s storage is Dense and the indices are already in the specified ordering so that no permutation is required.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that in the future we may return specialized AbstractArray types for certain storage types, for example a <code>LinearAlgebra.Diagonal</code> type for an ITensor with <code>Diag</code> storage. The specific storage type shouldn&#39;t be relied upon.</p></div></div><p>See also <a href="ITensorType.html#NDTensors.array-Tuple{ITensor, Vararg{Any}}"><code>array</code></a>, <a href="ITensorType.html#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}"><code>matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L223-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.array-Tuple{ITensor}" href="#NDTensors.array-Tuple{ITensor}"><code>NDTensors.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array(T::ITensor)</code></pre><p>Given an ITensor <code>T</code>, returns an Array with a copy of the ITensor&#39;s elements, or a view in the case the the ITensor&#39;s storage is Dense.</p><p>The ordering of the elements in the Array, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is intended for developer use only and not recommended for use in ITensor applications unless you know what you are doing (for example you are certain of the memory ordering of the ITensor because you permuted the indices into a certain order).</p></div></div><p>See also <a href="ITensorType.html#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}"><code>matrix</code></a>, <a href="ITensorType.html#NDTensors.vector-Tuple{ITensor, Vararg{Any}}"><code>vector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L116-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.matrix-Tuple{ITensor}" href="#NDTensors.matrix-Tuple{ITensor}"><code>NDTensors.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with two indices, returns a Matrix with a copy of the ITensor&#39;s elements, or a view in the case the ITensor&#39;s storage is Dense.</p><p>The ordering of the elements in the Matrix, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is intended for developer use only and not recommended for use in ITensor applications unless you know what you are doing (for example you are certain of the memory ordering of the ITensor because you permuted the indices into a certain order).</p></div></div><p>See also <a href="ITensorType.html#NDTensors.array-Tuple{ITensor, Vararg{Any}}"><code>array</code></a>, <a href="ITensorType.html#NDTensors.vector-Tuple{ITensor, Vararg{Any}}"><code>vector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L161-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.vector-Tuple{ITensor}" href="#NDTensors.vector-Tuple{ITensor}"><code>NDTensors.vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with one index, returns a Vector with a copy of the ITensor&#39;s elements, or a view in the case the ITensor&#39;s storage is Dense.</p><p>See also <a href="ITensorType.html#NDTensors.array-Tuple{ITensor, Vararg{Any}}"><code>array</code></a>, <a href="ITensorType.html#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}"><code>matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L209-L217">source</a></section></article><h2 id="Getting-and-setting-elements"><a class="docs-heading-anchor" href="#Getting-and-setting-elements">Getting and setting elements</a><a id="Getting-and-setting-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-setting-elements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ITensor, Vararg{Any}}" href="#Base.getindex-Tuple{ITensor, Vararg{Any}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(T::ITensor, ivs...)</code></pre><p>Get the specified element of the ITensor, using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">i = Index(2; tags = &quot;i&quot;)
A = ITensor(2.0, i, i&#39;)
A[i =&gt; 1, i&#39; =&gt; 2] # 2.0, same as: A[i&#39; =&gt; 2, i =&gt; 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1127-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{ITensor, Number, Vararg{Int64}}" href="#Base.setindex!-Tuple{ITensor, Number, Vararg{Int64}}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(T::ITensor, x::Number, ivs...)

setindex!(T::ITensor, x::Number, I::Integer...)

setindex!(T::ITensor, x::Number, I::CartesianIndex)</code></pre><p>Set the specified element of the ITensor, using a list of <code>Pair{&lt;:Index, Integer}</code> (or <code>IndexVal</code>).</p><p>If just integers are used, set the specified element of the ITensor using internal Index ordering of the ITensor (only for advanced usage, only use if you know the axact ordering of the indices).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">i = Index(2; tags = &quot;i&quot;)
A = ITensor(i, i&#39;)
A[i =&gt; 1, i&#39; =&gt; 2] = 1.0 # same as: A[i&#39; =&gt; 2, i =&gt; 1] = 1.0
A[1, 2] = 1.0 # same as: A[i =&gt; 1, i&#39; =&gt; 2] = 1.0

# Some simple slicing is also supported
A[i =&gt; 2, i&#39; =&gt; :] = [2.0 3.0]
A[2, :] = [2.0 3.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1199-L1224">source</a></section></article><h2 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NDTensors.inds-Tuple{ITensor}" href="#NDTensors.inds-Tuple{ITensor}"><code>NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inds(T::ITensor)</code></pre><p>Return the indices of the ITensor as a Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1312-L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.ind-Tuple{ITensor, Int64}" href="#NDTensors.ind-Tuple{ITensor, Int64}"><code>NDTensors.ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ind(T::ITensor, i::Int)</code></pre><p>Get the Index of the ITensor along dimension i.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1319-L1323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.dir-Tuple{ITensor, Index}" href="#ITensors.dir-Tuple{ITensor, Index}"><code>ITensors.dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dir(A::ITensor, i::Index)</code></pre><p>Return the direction of the Index <code>i</code> in the ITensor <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L847-L851">source</a></section></article><h2 id="Priming_and_tagging_ITensor"><a class="docs-heading-anchor" href="#Priming_and_tagging_ITensor">Priming and tagging</a><a id="Priming_and_tagging_ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Priming_and_tagging_ITensor" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.prime-Tuple{ITensor, Vararg{Any}}" href="#ITensors.prime-Tuple{ITensor, Vararg{Any}}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prime[!](A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; ITensor

prime(inds, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Increase the prime level of the indices of an ITensor or collection of indices.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1568-L1576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.setprime-Tuple{ITensor, Vararg{Any}}" href="#ITensors.setprime-Tuple{ITensor, Vararg{Any}}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setprime[!](A::ITensor, plev::Int; &lt;keyword arguments&gt;) -&gt; ITensor

setprime(inds, plev::Int; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or collection of indices.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1578-L1586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noprime-Tuple{ITensor, Vararg{Any}}" href="#ITensors.noprime-Tuple{ITensor, Vararg{Any}}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noprime[!](A::ITensor; &lt;keyword arguments&gt;) -&gt; ITensor

noprime(inds; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or collection of indices to zero.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1588-L1596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.mapprime-Tuple{ITensor, Vararg{Any}}" href="#ITensors.mapprime-Tuple{ITensor, Vararg{Any}}"><code>ITensors.mapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceprime[!](A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;) -&gt; ITensor
replaceprime[!](A::ITensor, plold =&gt; plnew; &lt;keyword arguments&gt;) -&gt; ITensor
mapprime[!](A::ITensor, &lt;arguments&gt;; &lt;keyword arguments&gt;) -&gt; ITensor

replaceprime(inds, plold::Int, plnew::Int; &lt;keyword arguments&gt;)
replaceprime(inds::IndexSet, plold =&gt; plnew; &lt;keyword arguments&gt;)
mapprime(inds, &lt;arguments&gt;; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor or collection of indices with prime level <code>plold</code> to <code>plnew</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1598-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swapprime-Tuple{ITensor, Vararg{Any}}" href="#ITensors.swapprime-Tuple{ITensor, Vararg{Any}}"><code>ITensors.swapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swapprime[!](A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;) -&gt; ITensor
swapprime[!](A::ITensor, pl1 =&gt; pl2; &lt;keyword arguments&gt;) -&gt; ITensor

swapprime(inds, pl1::Int, pl2::Int; &lt;keyword arguments&gt;)
swapprime(inds, pl1 =&gt; pl2; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor or collection of indices with prime level <code>pl1</code> to <code>pl2</code>, and those with prime level <code>pl2</code> to <code>pl1</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1613-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.addtags-Tuple{ITensor, Vararg{Any}}" href="#ITensors.addtags-Tuple{ITensor, Vararg{Any}}"><code>ITensors.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addtags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

addtags(inds, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Add the tags <code>ts</code> to the indices of an ITensor or collection of indices.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1626-L1634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.removetags-Tuple{ITensor, Vararg{Any}}" href="#ITensors.removetags-Tuple{ITensor, Vararg{Any}}"><code>ITensors.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">removetags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

removetags(inds, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Remove the tags <code>ts</code> from the indices of an ITensor or collection of indices.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1636-L1644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.replacetags-Tuple{ITensor, Vararg{Any}}" href="#ITensors.replacetags-Tuple{ITensor, Vararg{Any}}"><code>ITensors.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replacetags[!](A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; ITensor

replacetags(is::IndexSet, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Replace the tags <code>tsold</code> with <code>tsnew</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1656-L1664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.settags-Tuple{ITensor, Vararg{Any}}" href="#ITensors.settags-Tuple{ITensor, Vararg{Any}}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">settags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

settags(is::IndexSet, ts::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the tags of the indices of an ITensor or IndexSet to <code>ts</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1646-L1654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swaptags-Tuple{ITensor, Vararg{Any}}" href="#ITensors.swaptags-Tuple{ITensor, Vararg{Any}}"><code>ITensors.swaptags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swaptags[!](A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; ITensor

swaptags(is::IndexSet, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Swap the tags <code>ts1</code> with <code>ts2</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>.</li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1666-L1674">source</a></section></article><h2 id="Index-collections-set-operations"><a class="docs-heading-anchor" href="#Index-collections-set-operations">Index collections set operations</a><a id="Index-collections-set-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-collections-set-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.commoninds" href="#ITensors.commoninds"><code>ITensors.commoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commoninds(A, B; kwargs...)</code></pre><p>Return a Vector with indices that are common between the indices of <code>A</code> and <code>B</code> (the set intersection, similar to <code>Base.intersect</code>).</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1419-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.commonind" href="#ITensors.commonind"><code>ITensors.commonind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commonind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> common between the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.commoninds"><code>commoninds</code></a>.</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1429-L1437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.uniqueinds" href="#ITensors.uniqueinds"><code>ITensors.uniqueinds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniqueinds(A, B; kwargs...)</code></pre><p>Return Vector with indices that are unique to the set of indices of <code>A</code> and not in <code>B</code> (the set difference, similar to <code>Base.setdiff</code>).</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1461-L1468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.uniqueind" href="#ITensors.uniqueind"><code>ITensors.uniqueind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniqueind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> unique to the set of indices of <code>A</code> and not in <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.uniqueinds"><code>uniqueinds</code></a>.</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1471-L1479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noncommoninds" href="#ITensors.noncommoninds"><code>ITensors.noncommoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noncommoninds(A, B; kwargs...)</code></pre><p>Return a Vector with indices that are not common between the indices of <code>A</code> and <code>B</code> (the symmetric set difference, similar to <code>Base.symdiff</code>).</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1440-L1447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.noncommonind" href="#ITensors.noncommonind"><code>ITensors.noncommonind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noncommonind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> not common between the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.noncommoninds"><code>noncommoninds</code></a>.</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1450-L1458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.unioninds" href="#ITensors.unioninds"><code>ITensors.unioninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unioninds(A, B; kwargs...)</code></pre><p>Return a Vector with indices that are the union of the indices of <code>A</code> and <code>B</code> (the set union, similar to <code>Base.union</code>).</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1482-L1489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.unionind" href="#ITensors.unionind"><code>ITensors.unionind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unionind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> in the union of the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.unioninds"><code>unioninds</code></a>.</p><p>Optional keyword arguments:</p><ul><li>tags::String - a tag name or comma separated list of tag names that the returned indices must all have</li><li>plev::Int - common prime level that the returned indices must all have</li><li>inds - Index or collection of indices. Returned indices must come from this set of indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1492-L1500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.hascommoninds" href="#ITensors.hascommoninds"><code>ITensors.hascommoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hascommoninds(A, B; kwargs...)

hascommoninds(B; kwargs...) -&gt; f::Function</code></pre><p>Check if the ITensors or sets of indices <code>A</code> and <code>B</code> have common indices.</p><p>If only one ITensor or set of indices <code>B</code> is passed, return a function <code>f</code> such that <code>f(A) = hascommoninds(A, B; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1363-L1373">source</a></section></article><h2 id="Index-Manipulations"><a class="docs-heading-anchor" href="#Index-Manipulations">Index Manipulations</a><a id="Index-Manipulations-1"></a><a class="docs-heading-anchor-permalink" href="#Index-Manipulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.replaceind-Tuple{ITensor, Vararg{Any}}" href="#ITensors.replaceind-Tuple{ITensor, Vararg{Any}}"><code>ITensors.replaceind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceind[!](A::ITensor, i1::Index, i2::Index) -&gt; ITensor</code></pre><p>Replace the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1676-L1682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.replaceinds-Tuple{ITensor, Vararg{Any}}" href="#ITensors.replaceinds-Tuple{ITensor, Vararg{Any}}"><code>ITensors.replaceinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replaceinds(A::ITensor, inds1, inds2) -&gt; ITensor

replaceinds!(A::ITensor, inds1, inds2)</code></pre><p>Replace the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1684-L1696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swapind-Tuple{ITensor, Vararg{Any}}" href="#ITensors.swapind-Tuple{ITensor, Vararg{Any}}"><code>ITensors.swapind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swapind(A::ITensor, i1::Index, i2::Index) -&gt; ITensor

swapind!(A::ITensor, i1::Index, i2::Index)</code></pre><p>Swap the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1698-L1706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.swapinds-Tuple{ITensor, Vararg{Any}}" href="#ITensors.swapinds-Tuple{ITensor, Vararg{Any}}"><code>ITensors.swapinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swapinds(A::ITensor, inds1, inds2) -&gt; ITensor

swapinds!(A::ITensor, inds1, inds2)</code></pre><p>Swap the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1708-L1720">source</a></section></article><h2 id="Math-operations"><a class="docs-heading-anchor" href="#Math-operations">Math operations</a><a id="Math-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Math-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{ITensor, ITensor}" href="#Base.:*-Tuple{ITensor, ITensor}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A::ITensor * B::ITensor
contract(A::ITensor, B::ITensor)</code></pre><p>Contract ITensors A and B to obtain a new ITensor. This contraction <code>*</code> operator finds all matching indices common to A and B and sums over them, such that the result will have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be modified such that they no longer compare equal - for more information see the documentation on Index objects.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2,&quot;index_i&quot;); j = Index(4,&quot;index_j&quot;); k = Index(3,&quot;index_k&quot;)

A = randomITensor(i,j)
B = randomITensor(j,k)
C = A * B # contract over Index j

A = randomITensor(i,i&#39;)
B = randomITensor(i,i&#39;&#39;)
C = A * B # contract over Index i

A = randomITensor(i)
B = randomITensor(j)
C = A * B # outer product of A and B, no contraction

A = randomITensor(i,j,k)
B = randomITensor(k,i,j)
C = A * B # inner product of A and B, all indices contracted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/tensor_algebra.jl#L56-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ITensors.dag-Tuple{ITensor}" href="#ITensors.dag-Tuple{ITensor}"><code>ITensors.dag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dag(T::ITensor; allow_alias = true)</code></pre><p>Complex conjugate the elements of the ITensor <code>T</code> and dagger the indices.</p><p>By default, an alias of the ITensor is returned (i.e. the output ITensor may share data with the input ITensor). If <code>allow_alias = false</code>, an alias is never returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L1804-L1812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{ITensor, Any, Any}" href="#Base.exp-Tuple{ITensor, Any, Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(A::ITensor, Linds=Rinds&#39;, Rinds=inds(A,plev=0); ishermitian = false)</code></pre><p>Compute the exponential of the tensor <code>A</code> by treating it as a matrix <span>$A_{lr}$</span> with the left index <code>l</code> running over all indices in <code>Linds</code> and <code>r</code> running over all indices in <code>Rinds</code>.</p><p>Only accepts index lists <code>Linds</code>,<code>Rinds</code> such that: (1) <code>length(Linds) + length(Rinds) == length(inds(A))</code> (2) <code>length(Linds) == length(Rinds)</code> (3) For each pair of indices <code>(Linds[n],Rinds[n])</code>, <code>Linds[n]</code> and <code>Rinds[n]</code> represent the same Hilbert space (the same QN structure in the QN case, or just the same length in the dense case), and appear in <code>A</code> with opposite directions.</p><p>When <code>ishermitian=true</code> the exponential of <code>Hermitian(A_{lr})</code> is computed internally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/matrix_algebra.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.nullspace-Tuple{ITensor, Vararg{Any}}" href="#LinearAlgebra.nullspace-Tuple{ITensor, Vararg{Any}}"><code>LinearAlgebra.nullspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nullspace(T::ITensor, left_inds...; tags=&quot;n&quot;, atol=1E-12, kwargs...)</code></pre><p>Viewing the ITensor <code>T</code> as a matrix with the provided <code>left_inds</code> viewed as the row space and remaining indices viewed as the right indices or column space, the <code>nullspace</code> function computes the right null space. That is, it will return a tensor <code>N</code> acting on the right indices of <code>T</code> such that <code>T*N</code> is zero. The returned tensor <code>N</code> will also have a new index with the label &quot;n&quot; which indexes through the &#39;vectors&#39; in the null space.</p><p>For example, if <code>T</code> has the indices <code>i,j,k</code>, calling <code>N = nullspace(T,i,k)</code> returns <code>N</code> with index <code>j</code> such that</p><pre><code class="nohighlight hljs">       ___       ___
  i --|   |     |   |
      | T |--j--| N |--n  ≈ 0
  k --|   |     |   |
       ---       ---</code></pre><p>The index <code>n</code> can be obtained by calling <code>n = uniqueindex(N,T)</code></p><p>Note that the implementation of this function is subject to change in the future, in which case the precise <code>atol</code> value that gives a certain null space size may change in future versions of ITensor.</p><p>Keyword arguments:</p><ul><li><code>atol::Float64=1E-12</code> - singular values of T†*T below this value define the null space</li><li><code>tags::String=&quot;n&quot;</code> - choose the tags of the index selecting elements of the null space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/nullspace.jl#L150-L180">source</a></section></article><h2 id="Decompositions"><a class="docs-heading-anchor" href="#Decompositions">Decompositions</a><a id="Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Decompositions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.svd-Tuple{ITensor, Vararg{Any}}" href="#LinearAlgebra.svd-Tuple{ITensor, Vararg{Any}}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svd(A::ITensor, inds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Singular value decomposition (SVD) of an ITensor <code>A</code>, computed by treating the &quot;left indices&quot; provided collectively as a row index, and the remaining &quot;right indices&quot; as a column index (matricization of a tensor).</p><p>The first three return arguments are <code>U</code>, <code>S</code>, and <code>V</code>, such that <code>A ≈ U * S * V</code>.</p><p>Whether or not the SVD performs a trunction depends on the keyword arguments provided.</p><p>If the left or right set of indices are empty, all input indices are put on <code>V</code> or <code>U</code> respectively. To specify an empty set of left indices, you must explicitly use <code>svd(A, ())</code> (<code>svd(A)</code> is currently undefined).</p><p><strong>Examples</strong></p><p>Computing the SVD of an order-three ITensor, such that the indices i and k end up on U and j ends up on V</p><pre><code class="nohighlight hljs">i = Index(2)
j = Index(5)
k = Index(2)
A = randomITensor(i, j, k)
U, S, V = svd(A, i, k);
@show norm(A - U * S * V) &lt;= 10 * eps() * norm(A)</code></pre><p>The following code will truncate the last 2 singular values, since the total number of singular values is 4. The norm of the difference with the original tensor will be the sqrt root of the sum of the squares of the singular values that get truncated.</p><pre><code class="nohighlight hljs">trunc, Strunc, Vtrunc = svd(A, i, k; maxdim=2);
@show norm(A - Utrunc * Strunc * Vtrunc) ≈ sqrt(S[3, 3]^2 + S[4, 4]^2)</code></pre><p>Alternatively we can specify that we want to truncate the weights of the singular values up to a certain cutoff, so the total error will be no larger than the cutoff.</p><pre><code class="nohighlight hljs">Utrunc2, Strunc2, Vtrunc2 = svd(A, i, k; cutoff=1e-10);
@show norm(A - Utrunc2 * Strunc2 * Vtrunc2) &lt;= 1e-10</code></pre><p><strong>Keywords</strong></p><ul><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD,  by default defined as the sum of the squares of the smallest singular values.</li><li><code>lefttags::String = &quot;Link,u&quot;</code>: set the tags of the Index shared by <code>U</code> and <code>S</code>.</li><li><code>righttags::String = &quot;Link,v&quot;</code>: set the tags of the Index shared by <code>S</code> and <code>V</code>.</li><li><code>alg::String = &quot;divide_and_conquer&quot;</code>. Options:</li><li><code>&quot;divide_and_conquer&quot;</code> - A divide-and-conquer algorithm.    LAPACK&#39;s gesdd. Fast, but may lead to some innacurate singular values    for very ill-conditioned matrices. Also may sometimes fail to converge,    leading to errors (in which case &quot;qr_iteration&quot; or &quot;recursive&quot; can be tried).<ul><li><code>&quot;qr_iteration&quot;</code> - Typically slower but more accurate for very  ill-conditioned matrices compared to <code>&quot;divide_and_conquer&quot;</code>.  LAPACK&#39;s gesvd.</li><li><code>&quot;recursive&quot;</code> - ITensor&#39;s custom svd. Very reliable, but may be slow if  high precision is needed. To get an <code>svd</code> of a matrix <code>A</code>, an  eigendecomposition of <span>$A^{\dagger} A$</span> is used to compute <code>U</code> and then  a <code>qr</code> of <span>$A^{\dagger} U$</span> is used to compute <code>V</code>. This is performed  recursively to compute small singular values.</li></ul></li><li><code>use_absolute_cutoff::Bool = false</code>: set if all probability weights below  the <code>cutoff</code> value should be discarded, rather than the sum of discarded  weights.</li><li><code>use_relative_cutoff::Bool = true</code>: set if the singular values should be  normalized for the sake of truncation.</li><li><code>min_blockdim::Int = 0</code>: for SVD of block-sparse or QN ITensors, require  that the number of singular values kept be greater than or equal to  this value when possible</li></ul><p>See also: <a href="ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor, Vararg{Any}}"><code>factorize</code></a>, <a href="ITensorType.html#LinearAlgebra.eigen-Tuple{ITensor, Any, Any}"><code>eigen</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/matrix_decomposition.jl#L26-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.eigen-Tuple{ITensor, Any, Any}" href="#LinearAlgebra.eigen-Tuple{ITensor, Any, Any}"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigen(A::ITensor[, Linds, Rinds]; &lt;keyword arguments&gt;)</code></pre><p>Eigendecomposition of an ITensor <code>A</code>, computed by treating the &quot;left indices&quot; <code>Linds</code> provided collectively as a row index, and remaining &quot;right indices&quot; <code>Rinds</code> as a column index (matricization of a tensor).</p><p>If no indices are provided, pairs of primed and unprimed indices are searched for, with <code>Linds</code> taken to be the primed indices and <code>Rinds</code> taken to be the unprimed indices.</p><p>The return arguments are the eigenvalues <code>D</code> and eigenvectors <code>U</code> as tensors, such that <code>A * U ∼ U * D</code> (more precisely they are approximately equal up to proper replacements of indices, see the example for details).</p><p>Whether or not <code>eigen</code> performs a trunction depends on the keyword arguments provided. Note that truncation is only well defined for positive semidefinite matrices.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `maxdim::Int`: the maximum number of singular values to keep.
- `mindim::Int`: the minimum number of singular values to keep.
- `cutoff::Float64`: set the desired truncation error of the eigenvalues,
   by default defined as the sum of the squares of the smallest eigenvalues.
   For now truncation is only well defined for positive semi-definite
   eigenspectra.
- `ishermitian::Bool = false`: specify if the matrix is Hermitian, in which
   case a specialized diagonalization routine will be used and it is
   guaranteed that real eigenvalues will be returned.
- `plev::Int = 0`: set the prime level of the Indices of `D`. Default prime
   levels are subject to change.
- `leftplev::Int = plev`: set the prime level of the Index unique to `D`.
   Default prime levels are subject to change.
- `rightplev::Int = leftplev+1`: set the prime level of the Index shared
   by `D` and `U`. Default tags are subject to change.
- `tags::String = &quot;Link,eigen&quot;`: set the tags of the Indices of `D`.
   Default tags are subject to change.
- `lefttags::String = tags`: set the tags of the Index unique to `D`.
   Default tags are subject to change.
- `righttags::String = tags`: set the tags of the Index shared by `D` and `U`.
   Default tags are subject to change.
- `use_absolute_cutoff::Bool = false`: set if all probability weights below
   the `cutoff` value should be discarded, rather than the sum of discarded
   weights.
- `use_relative_cutoff::Bool = true`: set if the singular values should
   be normalized for the sake of truncation.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i, j, k, l = Index(2, &quot;i&quot;), Index(2, &quot;j&quot;), Index(2, &quot;k&quot;), Index(2, &quot;l&quot;)
A = randomITensor(i, j, k, l)
Linds = (i, k)
Rinds = (j, l)
D, U = eigen(A, Linds, Rinds)
dl, dr = uniqueind(D, U), commonind(D, U)
Ul = replaceinds(U, (Rinds..., dr) =&gt; (Linds..., dl))
A * U ≈ Ul * D # true</code></pre><p>See also: <a href="ITensorType.html#LinearAlgebra.svd-Tuple{ITensor, Vararg{Any}}"><code>svd</code></a>, <a href="ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor, Vararg{Any}}"><code>factorize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/matrix_decomposition.jl#L203-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.factorize-Tuple{ITensor, Vararg{Any}}" href="#LinearAlgebra.factorize-Tuple{ITensor, Vararg{Any}}"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorize(A::ITensor, Linds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Perform a factorization of <code>A</code> into ITensors <code>L</code> and <code>R</code> such that <code>A ≈ L * R</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ortho::String = &quot;left&quot;</code>: Choose orthogonality  properties of the factorization.<ul><li><code>&quot;left&quot;</code>: the left factor <code>L</code> is an orthogonal basis  such that <code>L * dag(prime(L, commonind(L,R))) ≈ I</code>.</li><li><code>&quot;right&quot;</code>: the right factor <code>R</code> forms an orthogonal basis.</li><li><code>&quot;none&quot;</code>, neither of the factors form an orthogonal basis,   and in general are made as symmetrically as possible   (depending on the decomposition used).</li></ul></li><li><code>which_decomp::Union{String, Nothing} = nothing</code>: choose what kind  of decomposition is used.<ul><li><code>nothing</code>: choose the decomposition automatically based on  the other arguments. For example, when <code>nothing</code> is chosen and  <code>ortho = &quot;left&quot;</code> or <code>&quot;right&quot;</code>, and a cutoff is provided, <code>svd</code> or  <code>eigen</code> is used depending on the provided cutoff (<code>eigen</code> is only  used when the cutoff is greater than <code>1e-12</code>, since it has a lower  precision). When no truncation is requested <code>qr</code> is used for dense  ITensors and <code>svd</code> for block-sparse ITensors (in the future <code>qr</code>  will be used also for block-sparse ITensors in this case).</li><li><code>&quot;svd&quot;</code>: <code>L = U</code> and <code>R = S * V</code> for <code>ortho = &quot;left&quot;</code>, <code>L = U * S</code>  and <code>R = V</code> for <code>ortho = &quot;right&quot;</code>, and <code>L = U * sqrt.(S)</code> and  <code>R = sqrt.(S) * V</code> for <code>ortho = &quot;none&quot;</code>. To control which <code>svd</code>  algorithm is choose, use the <code>svd_alg</code> keyword argument. See the  documentation for <code>svd</code> for the supported algorithms, which are the  same as those accepted by the <code>alg</code> keyword argument.</li><li><code>&quot;eigen&quot;</code>: <code>L = U</code> and <span>$R = U^{\dagger} A$</span> where <code>U</code> is determined  from the eigendecompositon <span>$A A^{\dagger} = U D U^{\dagger}$</span> for  <code>ortho = &quot;left&quot;</code> (and vice versa for <code>ortho = &quot;right&quot;</code>). <code>&quot;eigen&quot;</code> is  not supported for <code>ortho = &quot;none&quot;</code>.</li><li><code>&quot;qr&quot;</code>: <code>L=Q</code> and <code>R</code> an upper-triangular matrix when  <code>ortho = &quot;left&quot;</code>, and <code>R = Q</code> and <code>L</code> a lower-triangular matrix  when <code>ortho = &quot;right&quot;</code> (currently supported for dense ITensors only). In the future, other decompositions like QR (for block-sparse ITensors), polar, cholesky, LU, etc. are expected to be supported.</li></ul></li></ul><p>For truncation arguments, see: <a href="ITensorType.html#LinearAlgebra.svd-Tuple{ITensor, Vararg{Any}}"><code>svd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/matrix_decomposition.jl#L590-L632">source</a></section></article><h2 id="Memory-operations"><a class="docs-heading-anchor" href="#Memory-operations">Memory operations</a><a id="Memory-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ITensors.permute-Tuple{ITensor, Any}" href="#ITensors.permute-Tuple{ITensor, Any}"><code>ITensors.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permute(T::ITensor, inds...; allow_alias = false)</code></pre><p>Return a new ITensor <code>T</code> with indices permuted according to the input indices <code>inds</code>. The storage of the ITensor is permuted accordingly.</p><p>If called with <code>allow_alias = true</code>, it avoids copying data if possible. Therefore, it may return an alias of the input ITensor (an ITensor that shares the same data), such as if the permutation turns out to be trivial.</p><p>By default, <code>allow_alias = false</code>, and it never returns an alias of the input ITensor.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">i = Index(2, &quot;index_i&quot;); j = Index(4, &quot;index_j&quot;); k = Index(3, &quot;index_k&quot;);
T = randomITensor(i, j, k)

pT_1 = permute(T, k, i, j)
pT_2 = permute(T, j, i, k)

pT_noalias_1 = permute(T, i, j, k)
pT_noalias_1[1, 1, 1] = 12
T[1, 1, 1] != pT_noalias_1[1, 1, 1]

pT_noalias_2 = permute(T, i, j, k; allow_alias = false)
pT_noalias_2[1, 1, 1] = 12
T[1, 1, 1] != pT_noalias_1[1, 1, 1]

pT_alias = permute(T, i, j, k; allow_alias = true)
pT_alias[1, 1, 1] = 12
T[1, 1, 1] == pT_alias[1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/tensor_operations/permutations.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.dense-Tuple{ITensor}" href="#NDTensors.dense-Tuple{ITensor}"><code>NDTensors.dense</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dense(T::ITensor)</code></pre><p>Make a new ITensor where the storage is the closest Dense storage, avoiding allocating new data if possible. For example, an ITensor with Diag storage will become Dense storage, filled with zeros except for the diagonal values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L589-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.denseblocks-Tuple{ITensor}" href="#NDTensors.denseblocks-Tuple{ITensor}"><code>NDTensors.denseblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">denseblocks(T::ITensor)</code></pre><p>Make a new ITensor where any blocks which have a sparse format, such as diagonal sparsity, are made dense while still preserving the outer block-sparse structure. This method avoids allocating new data if possible.</p><p>For example, an ITensor with DiagBlockSparse storage will have BlockSparse storage afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ITensor/ITensors.jl/blob/8d3a807d65e92ec3c29fced845d2301011bd6a7a/src/itensor.jl#L990-L999">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="IndexSetType.html">« Index collections</a><a class="docs-footer-nextpage" href="MPSandMPO.html">MPS and MPO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 7 October 2023 00:09">Saturday 7 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
